
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Groups
 * 
 */
export type Groups = $Result.DefaultSelection<Prisma.$GroupsPayload>
/**
 * Model Students
 * 
 */
export type Students = $Result.DefaultSelection<Prisma.$StudentsPayload>
/**
 * Model TeacherGroups
 * 
 */
export type TeacherGroups = $Result.DefaultSelection<Prisma.$TeacherGroupsPayload>
/**
 * Model TestTasks
 * 
 */
export type TestTasks = $Result.DefaultSelection<Prisma.$TestTasksPayload>
/**
 * Model Questions
 * 
 */
export type Questions = $Result.DefaultSelection<Prisma.$QuestionsPayload>
/**
 * Model Answers
 * 
 */
export type Answers = $Result.DefaultSelection<Prisma.$AnswersPayload>
/**
 * Model Grades
 * 
 */
export type Grades = $Result.DefaultSelection<Prisma.$GradesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **Groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.GroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **Students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.StudentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherGroups`: Exposes CRUD operations for the **TeacherGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherGroups
    * const teacherGroups = await prisma.teacherGroups.findMany()
    * ```
    */
  get teacherGroups(): Prisma.TeacherGroupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testTasks`: Exposes CRUD operations for the **TestTasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestTasks
    * const testTasks = await prisma.testTasks.findMany()
    * ```
    */
  get testTasks(): Prisma.TestTasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **Questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.QuestionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answers`: Exposes CRUD operations for the **Answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.AnswersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grades`: Exposes CRUD operations for the **Grades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grades.findMany()
    * ```
    */
  get grades(): Prisma.GradesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    User: 'User',
    Teacher: 'Teacher',
    Groups: 'Groups',
    Students: 'Students',
    TeacherGroups: 'TeacherGroups',
    TestTasks: 'TestTasks',
    Questions: 'Questions',
    Answers: 'Answers',
    Grades: 'Grades'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "user" | "teacher" | "groups" | "students" | "teacherGroups" | "testTasks" | "questions" | "answers" | "grades"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Groups: {
        payload: Prisma.$GroupsPayload<ExtArgs>
        fields: Prisma.GroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findFirst: {
            args: Prisma.GroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findMany: {
            args: Prisma.GroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          create: {
            args: Prisma.GroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          createMany: {
            args: Prisma.GroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          delete: {
            args: Prisma.GroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          update: {
            args: Prisma.GroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          deleteMany: {
            args: Prisma.GroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          upsert: {
            args: Prisma.GroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.GroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupsCountArgs<ExtArgs>
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      Students: {
        payload: Prisma.$StudentsPayload<ExtArgs>
        fields: Prisma.StudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findFirst: {
            args: Prisma.StudentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findMany: {
            args: Prisma.StudentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          create: {
            args: Prisma.StudentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          createMany: {
            args: Prisma.StudentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          delete: {
            args: Prisma.StudentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          update: {
            args: Prisma.StudentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          upsert: {
            args: Prisma.StudentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.StudentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      TeacherGroups: {
        payload: Prisma.$TeacherGroupsPayload<ExtArgs>
        fields: Prisma.TeacherGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherGroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherGroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          findFirst: {
            args: Prisma.TeacherGroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherGroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          findMany: {
            args: Prisma.TeacherGroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>[]
          }
          create: {
            args: Prisma.TeacherGroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          createMany: {
            args: Prisma.TeacherGroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherGroupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>[]
          }
          delete: {
            args: Prisma.TeacherGroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          update: {
            args: Prisma.TeacherGroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          deleteMany: {
            args: Prisma.TeacherGroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherGroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherGroupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>[]
          }
          upsert: {
            args: Prisma.TeacherGroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherGroupsPayload>
          }
          aggregate: {
            args: Prisma.TeacherGroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherGroups>
          }
          groupBy: {
            args: Prisma.TeacherGroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherGroupsCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupsCountAggregateOutputType> | number
          }
        }
      }
      TestTasks: {
        payload: Prisma.$TestTasksPayload<ExtArgs>
        fields: Prisma.TestTasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestTasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestTasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          findFirst: {
            args: Prisma.TestTasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestTasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          findMany: {
            args: Prisma.TestTasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>[]
          }
          create: {
            args: Prisma.TestTasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          createMany: {
            args: Prisma.TestTasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestTasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>[]
          }
          delete: {
            args: Prisma.TestTasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          update: {
            args: Prisma.TestTasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          deleteMany: {
            args: Prisma.TestTasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestTasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestTasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>[]
          }
          upsert: {
            args: Prisma.TestTasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestTasksPayload>
          }
          aggregate: {
            args: Prisma.TestTasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestTasks>
          }
          groupBy: {
            args: Prisma.TestTasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestTasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestTasksCountArgs<ExtArgs>
            result: $Utils.Optional<TestTasksCountAggregateOutputType> | number
          }
        }
      }
      Questions: {
        payload: Prisma.$QuestionsPayload<ExtArgs>
        fields: Prisma.QuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findFirst: {
            args: Prisma.QuestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findMany: {
            args: Prisma.QuestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          create: {
            args: Prisma.QuestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          createMany: {
            args: Prisma.QuestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          delete: {
            args: Prisma.QuestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          update: {
            args: Prisma.QuestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          deleteMany: {
            args: Prisma.QuestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          upsert: {
            args: Prisma.QuestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.QuestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      Answers: {
        payload: Prisma.$AnswersPayload<ExtArgs>
        fields: Prisma.AnswersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findFirst: {
            args: Prisma.AnswersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findMany: {
            args: Prisma.AnswersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          create: {
            args: Prisma.AnswersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          createMany: {
            args: Prisma.AnswersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          delete: {
            args: Prisma.AnswersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          update: {
            args: Prisma.AnswersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          deleteMany: {
            args: Prisma.AnswersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnswersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          upsert: {
            args: Prisma.AnswersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.AnswersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswersCountArgs<ExtArgs>
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      Grades: {
        payload: Prisma.$GradesPayload<ExtArgs>
        fields: Prisma.GradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          findFirst: {
            args: Prisma.GradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          findMany: {
            args: Prisma.GradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>[]
          }
          create: {
            args: Prisma.GradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          createMany: {
            args: Prisma.GradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>[]
          }
          delete: {
            args: Prisma.GradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          update: {
            args: Prisma.GradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          deleteMany: {
            args: Prisma.GradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>[]
          }
          upsert: {
            args: Prisma.GradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradesPayload>
          }
          aggregate: {
            args: Prisma.GradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrades>
          }
          groupBy: {
            args: Prisma.GradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradesCountArgs<ExtArgs>
            result: $Utils.Optional<GradesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    user?: UserOmit
    teacher?: TeacherOmit
    groups?: GroupsOmit
    students?: StudentsOmit
    teacherGroups?: TeacherGroupsOmit
    testTasks?: TestTasksOmit
    questions?: QuestionsOmit
    answers?: AnswersOmit
    grades?: GradesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    students: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | UserCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    teacherGroups: number
    testTasks: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacherGroups?: boolean | TeacherCountOutputTypeCountTeacherGroupsArgs
    testTasks?: boolean | TeacherCountOutputTypeCountTestTasksArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeacherGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherGroupsWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTestTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTasksWhereInput
  }


  /**
   * Count Type GroupsCountOutputType
   */

  export type GroupsCountOutputType = {
    students: number
    teacherGroups: number
    testTasks: number
  }

  export type GroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | GroupsCountOutputTypeCountStudentsArgs
    teacherGroups?: boolean | GroupsCountOutputTypeCountTeacherGroupsArgs
    testTasks?: boolean | GroupsCountOutputTypeCountTestTasksArgs
  }

  // Custom InputTypes
  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     */
    select?: GroupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountTeacherGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherGroupsWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountTestTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTasksWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    grades: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grades?: boolean | StudentsCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradesWhereInput
  }


  /**
   * Count Type TestTasksCountOutputType
   */

  export type TestTasksCountOutputType = {
    questions: number
  }

  export type TestTasksCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | TestTasksCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * TestTasksCountOutputType without action
   */
  export type TestTasksCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasksCountOutputType
     */
    select?: TestTasksCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestTasksCountOutputType without action
   */
  export type TestTasksCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    answers: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionsCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    title: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    title?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly title: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleid: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleid: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    passwordhash: string | null
    login: string | null
    date: Date | null
    roleid: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    passwordhash: string | null
    login: string | null
    date: Date | null
    roleid: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    passwordhash: number
    login: number
    date: number
    roleid: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleid?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleid?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    passwordhash?: true
    login?: true
    date?: true
    roleid?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    passwordhash?: true
    login?: true
    date?: true
    roleid?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    passwordhash?: true
    login?: true
    date?: true
    roleid?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    passwordhash: string
    login: string
    date: Date
    roleid: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordhash?: boolean
    login?: boolean
    date?: boolean
    roleid?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    teachers?: boolean | User$teachersArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordhash?: boolean
    login?: boolean
    date?: boolean
    roleid?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    passwordhash?: boolean
    login?: boolean
    date?: boolean
    roleid?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    passwordhash?: boolean
    login?: boolean
    date?: boolean
    roleid?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "passwordhash" | "login" | "date" | "roleid", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    teachers?: boolean | User$teachersArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      teachers: Prisma.$TeacherPayload<ExtArgs> | null
      students: Prisma.$StudentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      passwordhash: string
      login: string
      date: Date
      roleid: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teachers<T extends User$teachersArgs<ExtArgs> = {}>(args?: Subset<T, User$teachersArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends User$studentsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly passwordhash: FieldRef<"User", 'String'>
    readonly login: FieldRef<"User", 'String'>
    readonly date: FieldRef<"User", 'DateTime'>
    readonly roleid: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.teachers
   */
  export type User$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.students
   */
  export type User$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    cursor?: StudentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type TeacherSumAggregateOutputType = {
    id: number | null
    userid: number | null
  }

  export type TeacherMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    patronymic: string | null
    userid: number | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    patronymic: string | null
    userid: number | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    name: number
    lastname: number
    patronymic: number
    userid: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    id?: true
    userid?: true
  }

  export type TeacherSumAggregateInputType = {
    id?: true
    userid?: true
  }

  export type TeacherMinAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userid?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userid?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userid?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: number
    name: string
    lastname: string
    patronymic: string
    userid: number
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userid?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    teacherGroups?: boolean | Teacher$teacherGroupsArgs<ExtArgs>
    testTasks?: boolean | Teacher$testTasksArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userid?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userid?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userid?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "lastname" | "patronymic" | "userid", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    teacherGroups?: boolean | Teacher$teacherGroupsArgs<ExtArgs>
    testTasks?: boolean | Teacher$testTasksArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
      teacherGroups: Prisma.$TeacherGroupsPayload<ExtArgs>[]
      testTasks: Prisma.$TestTasksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      lastname: string
      patronymic: string
      userid: number
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {TeacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacherGroups<T extends Teacher$teacherGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$teacherGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testTasks<T extends Teacher$testTasksArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$testTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'Int'>
    readonly name: FieldRef<"Teacher", 'String'>
    readonly lastname: FieldRef<"Teacher", 'String'>
    readonly patronymic: FieldRef<"Teacher", 'String'>
    readonly userid: FieldRef<"Teacher", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher updateManyAndReturn
   */
  export type TeacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher.teacherGroups
   */
  export type Teacher$teacherGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    where?: TeacherGroupsWhereInput
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    cursor?: TeacherGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherGroupsScalarFieldEnum | TeacherGroupsScalarFieldEnum[]
  }

  /**
   * Teacher.testTasks
   */
  export type Teacher$testTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    where?: TestTasksWhereInput
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    cursor?: TestTasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTasksScalarFieldEnum | TestTasksScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsAvgAggregateOutputType = {
    id: number | null
    course: number | null
  }

  export type GroupsSumAggregateOutputType = {
    id: number | null
    course: number | null
  }

  export type GroupsMinAggregateOutputType = {
    id: number | null
    title: string | null
    course: number | null
  }

  export type GroupsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    course: number | null
  }

  export type GroupsCountAggregateOutputType = {
    id: number
    title: number
    course: number
    _all: number
  }


  export type GroupsAvgAggregateInputType = {
    id?: true
    course?: true
  }

  export type GroupsSumAggregateInputType = {
    id?: true
    course?: true
  }

  export type GroupsMinAggregateInputType = {
    id?: true
    title?: true
    course?: true
  }

  export type GroupsMaxAggregateInputType = {
    id?: true
    title?: true
    course?: true
  }

  export type GroupsCountAggregateInputType = {
    id?: true
    title?: true
    course?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to aggregate.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type GroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithAggregationInput | GroupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: GroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _avg?: GroupsAvgAggregateInputType
    _sum?: GroupsSumAggregateInputType
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    id: number
    title: string
    course: number
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends GroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type GroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    course?: boolean
    students?: boolean | Groups$studentsArgs<ExtArgs>
    teacherGroups?: boolean | Groups$teacherGroupsArgs<ExtArgs>
    testTasks?: boolean | Groups$testTasksArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    course?: boolean
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    course?: boolean
  }, ExtArgs["result"]["groups"]>

  export type GroupsSelectScalar = {
    id?: boolean
    title?: boolean
    course?: boolean
  }

  export type GroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "course", ExtArgs["result"]["groups"]>
  export type GroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | Groups$studentsArgs<ExtArgs>
    teacherGroups?: boolean | Groups$teacherGroupsArgs<ExtArgs>
    testTasks?: boolean | Groups$testTasksArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Groups"
    objects: {
      students: Prisma.$StudentsPayload<ExtArgs>[]
      teacherGroups: Prisma.$TeacherGroupsPayload<ExtArgs>[]
      testTasks: Prisma.$TestTasksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      course: number
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }

  type GroupsGetPayload<S extends boolean | null | undefined | GroupsDefaultArgs> = $Result.GetResult<Prisma.$GroupsPayload, S>

  type GroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface GroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Groups'], meta: { name: 'Groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {GroupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupsFindUniqueArgs>(args: SelectSubset<T, GroupsFindUniqueArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupsFindFirstArgs>(args?: SelectSubset<T, GroupsFindFirstArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsWithIdOnly = await prisma.groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupsFindManyArgs>(args?: SelectSubset<T, GroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Groups.
     * @param {GroupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
     */
    create<T extends GroupsCreateArgs>(args: SelectSubset<T, GroupsCreateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupsCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupsCreateManyArgs>(args?: SelectSubset<T, GroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupsCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Groups.
     * @param {GroupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
     */
    delete<T extends GroupsDeleteArgs>(args: SelectSubset<T, GroupsDeleteArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Groups.
     * @param {GroupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupsUpdateArgs>(args: SelectSubset<T, GroupsUpdateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupsDeleteManyArgs>(args?: SelectSubset<T, GroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupsUpdateManyArgs>(args: SelectSubset<T, GroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupsUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Groups.
     * @param {GroupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
     */
    upsert<T extends GroupsUpsertArgs>(args: SelectSubset<T, GroupsUpsertArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupsCountArgs>(
      args?: Subset<T, GroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupsGroupByArgs['orderBy'] }
        : { orderBy?: GroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Groups model
   */
  readonly fields: GroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends Groups$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacherGroups<T extends Groups$teacherGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$teacherGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testTasks<T extends Groups$testTasksArgs<ExtArgs> = {}>(args?: Subset<T, Groups$testTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Groups model
   */
  interface GroupsFieldRefs {
    readonly id: FieldRef<"Groups", 'Int'>
    readonly title: FieldRef<"Groups", 'String'>
    readonly course: FieldRef<"Groups", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Groups findUnique
   */
  export type GroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findUniqueOrThrow
   */
  export type GroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findFirst
   */
  export type GroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findFirstOrThrow
   */
  export type GroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findMany
   */
  export type GroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups create
   */
  export type GroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a Groups.
     */
    data: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
  }

  /**
   * Groups createMany
   */
  export type GroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupsCreateManyInput | GroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Groups createManyAndReturn
   */
  export type GroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupsCreateManyInput | GroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Groups update
   */
  export type GroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a Groups.
     */
    data: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
    /**
     * Choose, which Groups to update.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups updateMany
   */
  export type GroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Groups updateManyAndReturn
   */
  export type GroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Groups upsert
   */
  export type GroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the Groups to update in case it exists.
     */
    where: GroupsWhereUniqueInput
    /**
     * In case the Groups found by the `where` argument doesn't exist, create a new Groups with this data.
     */
    create: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
    /**
     * In case the Groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
  }

  /**
   * Groups delete
   */
  export type GroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter which Groups to delete.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups deleteMany
   */
  export type GroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupsWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Groups.students
   */
  export type Groups$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    cursor?: StudentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Groups.teacherGroups
   */
  export type Groups$teacherGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    where?: TeacherGroupsWhereInput
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    cursor?: TeacherGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherGroupsScalarFieldEnum | TeacherGroupsScalarFieldEnum[]
  }

  /**
   * Groups.testTasks
   */
  export type Groups$testTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    where?: TestTasksWhereInput
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    cursor?: TestTasksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestTasksScalarFieldEnum | TestTasksScalarFieldEnum[]
  }

  /**
   * Groups without action
   */
  export type GroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Groups
     */
    omit?: GroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
  }


  /**
   * Model Students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type StudentsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    groupId: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    patronymic: string | null
    userId: number | null
    groupId: number | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    lastname: string | null
    patronymic: string | null
    userId: number | null
    groupId: number | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    name: number
    lastname: number
    patronymic: number
    userId: number
    groupId: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type StudentsSumAggregateInputType = {
    id?: true
    userId?: true
    groupId?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userId?: true
    groupId?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userId?: true
    groupId?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    name?: true
    lastname?: true
    patronymic?: true
    userId?: true
    groupId?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to aggregate.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type StudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithAggregationInput | StudentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: StudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: number
    name: string
    lastname: string
    patronymic: string
    userId: number
    groupId: number
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends StudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userId?: boolean
    groupId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
    grades?: boolean | Students$gradesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userId?: boolean
    groupId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userId?: boolean
    groupId?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectScalar = {
    id?: boolean
    name?: boolean
    lastname?: boolean
    patronymic?: boolean
    userId?: boolean
    groupId?: boolean
  }

  export type StudentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "lastname" | "patronymic" | "userId" | "groupId", ExtArgs["result"]["students"]>
  export type StudentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
    grades?: boolean | Students$gradesArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }
  export type StudentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }

  export type $StudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Students"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupsPayload<ExtArgs>
      grades: Prisma.$GradesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      lastname: string
      patronymic: string
      userId: number
      groupId: number
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type StudentsGetPayload<S extends boolean | null | undefined | StudentsDefaultArgs> = $Result.GetResult<Prisma.$StudentsPayload, S>

  type StudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface StudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Students'], meta: { name: 'Students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {StudentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentsFindUniqueArgs>(args: SelectSubset<T, StudentsFindUniqueArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentsFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentsFindFirstArgs>(args?: SelectSubset<T, StudentsFindFirstArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentsFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentsFindManyArgs>(args?: SelectSubset<T, StudentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {StudentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends StudentsCreateArgs>(args: SelectSubset<T, StudentsCreateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentsCreateManyArgs>(args?: SelectSubset<T, StudentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentsCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {StudentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends StudentsDeleteArgs>(args: SelectSubset<T, StudentsDeleteArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {StudentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentsUpdateArgs>(args: SelectSubset<T, StudentsUpdateArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentsDeleteManyArgs>(args?: SelectSubset<T, StudentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentsUpdateManyArgs>(args: SelectSubset<T, StudentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentsUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {StudentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends StudentsUpsertArgs>(args: SelectSubset<T, StudentsUpsertArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentsCountArgs>(
      args?: Subset<T, StudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Students model
   */
  readonly fields: StudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grades<T extends Students$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Students$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Students model
   */
  interface StudentsFieldRefs {
    readonly id: FieldRef<"Students", 'Int'>
    readonly name: FieldRef<"Students", 'String'>
    readonly lastname: FieldRef<"Students", 'String'>
    readonly patronymic: FieldRef<"Students", 'String'>
    readonly userId: FieldRef<"Students", 'Int'>
    readonly groupId: FieldRef<"Students", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Students findUnique
   */
  export type StudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findUniqueOrThrow
   */
  export type StudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students findFirst
   */
  export type StudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findFirstOrThrow
   */
  export type StudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students findMany
   */
  export type StudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * Students create
   */
  export type StudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Students.
     */
    data: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
  }

  /**
   * Students createMany
   */
  export type StudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Students createManyAndReturn
   */
  export type StudentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Students update
   */
  export type StudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Students.
     */
    data: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
    /**
     * Choose, which Students to update.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students updateMany
   */
  export type StudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Students updateManyAndReturn
   */
  export type StudentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Students upsert
   */
  export type StudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Students to update in case it exists.
     */
    where: StudentsWhereUniqueInput
    /**
     * In case the Students found by the `where` argument doesn't exist, create a new Students with this data.
     */
    create: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
    /**
     * In case the Students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
  }

  /**
   * Students delete
   */
  export type StudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter which Students to delete.
     */
    where: StudentsWhereUniqueInput
  }

  /**
   * Students deleteMany
   */
  export type StudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentsWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Students.grades
   */
  export type Students$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    where?: GradesWhereInput
    orderBy?: GradesOrderByWithRelationInput | GradesOrderByWithRelationInput[]
    cursor?: GradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * Students without action
   */
  export type StudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Students
     */
    omit?: StudentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentsInclude<ExtArgs> | null
  }


  /**
   * Model TeacherGroups
   */

  export type AggregateTeacherGroups = {
    _count: TeacherGroupsCountAggregateOutputType | null
    _avg: TeacherGroupsAvgAggregateOutputType | null
    _sum: TeacherGroupsSumAggregateOutputType | null
    _min: TeacherGroupsMinAggregateOutputType | null
    _max: TeacherGroupsMaxAggregateOutputType | null
  }

  export type TeacherGroupsAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
    groupId: number | null
  }

  export type TeacherGroupsSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
    groupId: number | null
  }

  export type TeacherGroupsMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    groupId: number | null
  }

  export type TeacherGroupsMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    groupId: number | null
  }

  export type TeacherGroupsCountAggregateOutputType = {
    id: number
    teacherId: number
    groupId: number
    _all: number
  }


  export type TeacherGroupsAvgAggregateInputType = {
    id?: true
    teacherId?: true
    groupId?: true
  }

  export type TeacherGroupsSumAggregateInputType = {
    id?: true
    teacherId?: true
    groupId?: true
  }

  export type TeacherGroupsMinAggregateInputType = {
    id?: true
    teacherId?: true
    groupId?: true
  }

  export type TeacherGroupsMaxAggregateInputType = {
    id?: true
    teacherId?: true
    groupId?: true
  }

  export type TeacherGroupsCountAggregateInputType = {
    id?: true
    teacherId?: true
    groupId?: true
    _all?: true
  }

  export type TeacherGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherGroups to aggregate.
     */
    where?: TeacherGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherGroups to fetch.
     */
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherGroups
    **/
    _count?: true | TeacherGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherGroupsMaxAggregateInputType
  }

  export type GetTeacherGroupsAggregateType<T extends TeacherGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherGroups[P]>
      : GetScalarType<T[P], AggregateTeacherGroups[P]>
  }




  export type TeacherGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherGroupsWhereInput
    orderBy?: TeacherGroupsOrderByWithAggregationInput | TeacherGroupsOrderByWithAggregationInput[]
    by: TeacherGroupsScalarFieldEnum[] | TeacherGroupsScalarFieldEnum
    having?: TeacherGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherGroupsCountAggregateInputType | true
    _avg?: TeacherGroupsAvgAggregateInputType
    _sum?: TeacherGroupsSumAggregateInputType
    _min?: TeacherGroupsMinAggregateInputType
    _max?: TeacherGroupsMaxAggregateInputType
  }

  export type TeacherGroupsGroupByOutputType = {
    id: number
    teacherId: number
    groupId: number
    _count: TeacherGroupsCountAggregateOutputType | null
    _avg: TeacherGroupsAvgAggregateOutputType | null
    _sum: TeacherGroupsSumAggregateOutputType | null
    _min: TeacherGroupsMinAggregateOutputType | null
    _max: TeacherGroupsMaxAggregateOutputType | null
  }

  type GetTeacherGroupsGroupByPayload<T extends TeacherGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupsGroupByOutputType[P]>
        }
      >
    >


  export type TeacherGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    groupId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherGroups"]>

  export type TeacherGroupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    groupId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherGroups"]>

  export type TeacherGroupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    groupId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherGroups"]>

  export type TeacherGroupsSelectScalar = {
    id?: boolean
    teacherId?: boolean
    groupId?: boolean
  }

  export type TeacherGroupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "groupId", ExtArgs["result"]["teacherGroups"]>
  export type TeacherGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }
  export type TeacherGroupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }
  export type TeacherGroupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    group?: boolean | GroupsDefaultArgs<ExtArgs>
  }

  export type $TeacherGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherGroups"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      group: Prisma.$GroupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number
      groupId: number
    }, ExtArgs["result"]["teacherGroups"]>
    composites: {}
  }

  type TeacherGroupsGetPayload<S extends boolean | null | undefined | TeacherGroupsDefaultArgs> = $Result.GetResult<Prisma.$TeacherGroupsPayload, S>

  type TeacherGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherGroupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherGroupsCountAggregateInputType | true
    }

  export interface TeacherGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherGroups'], meta: { name: 'TeacherGroups' } }
    /**
     * Find zero or one TeacherGroups that matches the filter.
     * @param {TeacherGroupsFindUniqueArgs} args - Arguments to find a TeacherGroups
     * @example
     * // Get one TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherGroupsFindUniqueArgs>(args: SelectSubset<T, TeacherGroupsFindUniqueArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherGroups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherGroupsFindUniqueOrThrowArgs} args - Arguments to find a TeacherGroups
     * @example
     * // Get one TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherGroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherGroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsFindFirstArgs} args - Arguments to find a TeacherGroups
     * @example
     * // Get one TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherGroupsFindFirstArgs>(args?: SelectSubset<T, TeacherGroupsFindFirstArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsFindFirstOrThrowArgs} args - Arguments to find a TeacherGroups
     * @example
     * // Get one TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherGroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherGroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findMany()
     * 
     * // Get first 10 TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherGroupsWithIdOnly = await prisma.teacherGroups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherGroupsFindManyArgs>(args?: SelectSubset<T, TeacherGroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherGroups.
     * @param {TeacherGroupsCreateArgs} args - Arguments to create a TeacherGroups.
     * @example
     * // Create one TeacherGroups
     * const TeacherGroups = await prisma.teacherGroups.create({
     *   data: {
     *     // ... data to create a TeacherGroups
     *   }
     * })
     * 
     */
    create<T extends TeacherGroupsCreateArgs>(args: SelectSubset<T, TeacherGroupsCreateArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherGroups.
     * @param {TeacherGroupsCreateManyArgs} args - Arguments to create many TeacherGroups.
     * @example
     * // Create many TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherGroupsCreateManyArgs>(args?: SelectSubset<T, TeacherGroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherGroups and returns the data saved in the database.
     * @param {TeacherGroupsCreateManyAndReturnArgs} args - Arguments to create many TeacherGroups.
     * @example
     * // Create many TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherGroups and only return the `id`
     * const teacherGroupsWithIdOnly = await prisma.teacherGroups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherGroupsCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherGroupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherGroups.
     * @param {TeacherGroupsDeleteArgs} args - Arguments to delete one TeacherGroups.
     * @example
     * // Delete one TeacherGroups
     * const TeacherGroups = await prisma.teacherGroups.delete({
     *   where: {
     *     // ... filter to delete one TeacherGroups
     *   }
     * })
     * 
     */
    delete<T extends TeacherGroupsDeleteArgs>(args: SelectSubset<T, TeacherGroupsDeleteArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherGroups.
     * @param {TeacherGroupsUpdateArgs} args - Arguments to update one TeacherGroups.
     * @example
     * // Update one TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherGroupsUpdateArgs>(args: SelectSubset<T, TeacherGroupsUpdateArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherGroups.
     * @param {TeacherGroupsDeleteManyArgs} args - Arguments to filter TeacherGroups to delete.
     * @example
     * // Delete a few TeacherGroups
     * const { count } = await prisma.teacherGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherGroupsDeleteManyArgs>(args?: SelectSubset<T, TeacherGroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherGroupsUpdateManyArgs>(args: SelectSubset<T, TeacherGroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherGroups and returns the data updated in the database.
     * @param {TeacherGroupsUpdateManyAndReturnArgs} args - Arguments to update many TeacherGroups.
     * @example
     * // Update many TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherGroups and only return the `id`
     * const teacherGroupsWithIdOnly = await prisma.teacherGroups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherGroupsUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherGroupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherGroups.
     * @param {TeacherGroupsUpsertArgs} args - Arguments to update or create a TeacherGroups.
     * @example
     * // Update or create a TeacherGroups
     * const teacherGroups = await prisma.teacherGroups.upsert({
     *   create: {
     *     // ... data to create a TeacherGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherGroups we want to update
     *   }
     * })
     */
    upsert<T extends TeacherGroupsUpsertArgs>(args: SelectSubset<T, TeacherGroupsUpsertArgs<ExtArgs>>): Prisma__TeacherGroupsClient<$Result.GetResult<Prisma.$TeacherGroupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsCountArgs} args - Arguments to filter TeacherGroups to count.
     * @example
     * // Count the number of TeacherGroups
     * const count = await prisma.teacherGroups.count({
     *   where: {
     *     // ... the filter for the TeacherGroups we want to count
     *   }
     * })
    **/
    count<T extends TeacherGroupsCountArgs>(
      args?: Subset<T, TeacherGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherGroupsAggregateArgs>(args: Subset<T, TeacherGroupsAggregateArgs>): Prisma.PrismaPromise<GetTeacherGroupsAggregateType<T>>

    /**
     * Group by TeacherGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupsGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherGroups model
   */
  readonly fields: TeacherGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherGroups model
   */
  interface TeacherGroupsFieldRefs {
    readonly id: FieldRef<"TeacherGroups", 'Int'>
    readonly teacherId: FieldRef<"TeacherGroups", 'Int'>
    readonly groupId: FieldRef<"TeacherGroups", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeacherGroups findUnique
   */
  export type TeacherGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter, which TeacherGroups to fetch.
     */
    where: TeacherGroupsWhereUniqueInput
  }

  /**
   * TeacherGroups findUniqueOrThrow
   */
  export type TeacherGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter, which TeacherGroups to fetch.
     */
    where: TeacherGroupsWhereUniqueInput
  }

  /**
   * TeacherGroups findFirst
   */
  export type TeacherGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter, which TeacherGroups to fetch.
     */
    where?: TeacherGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherGroups to fetch.
     */
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherGroups.
     */
    cursor?: TeacherGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherGroups.
     */
    distinct?: TeacherGroupsScalarFieldEnum | TeacherGroupsScalarFieldEnum[]
  }

  /**
   * TeacherGroups findFirstOrThrow
   */
  export type TeacherGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter, which TeacherGroups to fetch.
     */
    where?: TeacherGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherGroups to fetch.
     */
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherGroups.
     */
    cursor?: TeacherGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherGroups.
     */
    distinct?: TeacherGroupsScalarFieldEnum | TeacherGroupsScalarFieldEnum[]
  }

  /**
   * TeacherGroups findMany
   */
  export type TeacherGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter, which TeacherGroups to fetch.
     */
    where?: TeacherGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherGroups to fetch.
     */
    orderBy?: TeacherGroupsOrderByWithRelationInput | TeacherGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherGroups.
     */
    cursor?: TeacherGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherGroups.
     */
    skip?: number
    distinct?: TeacherGroupsScalarFieldEnum | TeacherGroupsScalarFieldEnum[]
  }

  /**
   * TeacherGroups create
   */
  export type TeacherGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherGroups.
     */
    data: XOR<TeacherGroupsCreateInput, TeacherGroupsUncheckedCreateInput>
  }

  /**
   * TeacherGroups createMany
   */
  export type TeacherGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherGroups.
     */
    data: TeacherGroupsCreateManyInput | TeacherGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherGroups createManyAndReturn
   */
  export type TeacherGroupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherGroups.
     */
    data: TeacherGroupsCreateManyInput | TeacherGroupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherGroups update
   */
  export type TeacherGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherGroups.
     */
    data: XOR<TeacherGroupsUpdateInput, TeacherGroupsUncheckedUpdateInput>
    /**
     * Choose, which TeacherGroups to update.
     */
    where: TeacherGroupsWhereUniqueInput
  }

  /**
   * TeacherGroups updateMany
   */
  export type TeacherGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherGroups.
     */
    data: XOR<TeacherGroupsUpdateManyMutationInput, TeacherGroupsUncheckedUpdateManyInput>
    /**
     * Filter which TeacherGroups to update
     */
    where?: TeacherGroupsWhereInput
    /**
     * Limit how many TeacherGroups to update.
     */
    limit?: number
  }

  /**
   * TeacherGroups updateManyAndReturn
   */
  export type TeacherGroupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * The data used to update TeacherGroups.
     */
    data: XOR<TeacherGroupsUpdateManyMutationInput, TeacherGroupsUncheckedUpdateManyInput>
    /**
     * Filter which TeacherGroups to update
     */
    where?: TeacherGroupsWhereInput
    /**
     * Limit how many TeacherGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherGroups upsert
   */
  export type TeacherGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherGroups to update in case it exists.
     */
    where: TeacherGroupsWhereUniqueInput
    /**
     * In case the TeacherGroups found by the `where` argument doesn't exist, create a new TeacherGroups with this data.
     */
    create: XOR<TeacherGroupsCreateInput, TeacherGroupsUncheckedCreateInput>
    /**
     * In case the TeacherGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherGroupsUpdateInput, TeacherGroupsUncheckedUpdateInput>
  }

  /**
   * TeacherGroups delete
   */
  export type TeacherGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
    /**
     * Filter which TeacherGroups to delete.
     */
    where: TeacherGroupsWhereUniqueInput
  }

  /**
   * TeacherGroups deleteMany
   */
  export type TeacherGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherGroups to delete
     */
    where?: TeacherGroupsWhereInput
    /**
     * Limit how many TeacherGroups to delete.
     */
    limit?: number
  }

  /**
   * TeacherGroups without action
   */
  export type TeacherGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherGroups
     */
    select?: TeacherGroupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherGroups
     */
    omit?: TeacherGroupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherGroupsInclude<ExtArgs> | null
  }


  /**
   * Model TestTasks
   */

  export type AggregateTestTasks = {
    _count: TestTasksCountAggregateOutputType | null
    _avg: TestTasksAvgAggregateOutputType | null
    _sum: TestTasksSumAggregateOutputType | null
    _min: TestTasksMinAggregateOutputType | null
    _max: TestTasksMaxAggregateOutputType | null
  }

  export type TestTasksAvgAggregateOutputType = {
    id: number | null
    groupid: number | null
    time: number | null
    teacherid: number | null
  }

  export type TestTasksSumAggregateOutputType = {
    id: number | null
    groupid: number | null
    time: number | null
    teacherid: number | null
  }

  export type TestTasksMinAggregateOutputType = {
    id: number | null
    title: string | null
    groupid: number | null
    description: string | null
    img: string | null
    beginningdate: Date | null
    enddatetime: Date | null
    time: number | null
    teacherid: number | null
  }

  export type TestTasksMaxAggregateOutputType = {
    id: number | null
    title: string | null
    groupid: number | null
    description: string | null
    img: string | null
    beginningdate: Date | null
    enddatetime: Date | null
    time: number | null
    teacherid: number | null
  }

  export type TestTasksCountAggregateOutputType = {
    id: number
    title: number
    groupid: number
    description: number
    img: number
    beginningdate: number
    enddatetime: number
    time: number
    teacherid: number
    _all: number
  }


  export type TestTasksAvgAggregateInputType = {
    id?: true
    groupid?: true
    time?: true
    teacherid?: true
  }

  export type TestTasksSumAggregateInputType = {
    id?: true
    groupid?: true
    time?: true
    teacherid?: true
  }

  export type TestTasksMinAggregateInputType = {
    id?: true
    title?: true
    groupid?: true
    description?: true
    img?: true
    beginningdate?: true
    enddatetime?: true
    time?: true
    teacherid?: true
  }

  export type TestTasksMaxAggregateInputType = {
    id?: true
    title?: true
    groupid?: true
    description?: true
    img?: true
    beginningdate?: true
    enddatetime?: true
    time?: true
    teacherid?: true
  }

  export type TestTasksCountAggregateInputType = {
    id?: true
    title?: true
    groupid?: true
    description?: true
    img?: true
    beginningdate?: true
    enddatetime?: true
    time?: true
    teacherid?: true
    _all?: true
  }

  export type TestTasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTasks to aggregate.
     */
    where?: TestTasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTasks to fetch.
     */
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestTasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestTasks
    **/
    _count?: true | TestTasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestTasksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestTasksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestTasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestTasksMaxAggregateInputType
  }

  export type GetTestTasksAggregateType<T extends TestTasksAggregateArgs> = {
        [P in keyof T & keyof AggregateTestTasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestTasks[P]>
      : GetScalarType<T[P], AggregateTestTasks[P]>
  }




  export type TestTasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestTasksWhereInput
    orderBy?: TestTasksOrderByWithAggregationInput | TestTasksOrderByWithAggregationInput[]
    by: TestTasksScalarFieldEnum[] | TestTasksScalarFieldEnum
    having?: TestTasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestTasksCountAggregateInputType | true
    _avg?: TestTasksAvgAggregateInputType
    _sum?: TestTasksSumAggregateInputType
    _min?: TestTasksMinAggregateInputType
    _max?: TestTasksMaxAggregateInputType
  }

  export type TestTasksGroupByOutputType = {
    id: number
    title: string
    groupid: number
    description: string
    img: string | null
    beginningdate: Date
    enddatetime: Date
    time: number
    teacherid: number
    _count: TestTasksCountAggregateOutputType | null
    _avg: TestTasksAvgAggregateOutputType | null
    _sum: TestTasksSumAggregateOutputType | null
    _min: TestTasksMinAggregateOutputType | null
    _max: TestTasksMaxAggregateOutputType | null
  }

  type GetTestTasksGroupByPayload<T extends TestTasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestTasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestTasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestTasksGroupByOutputType[P]>
            : GetScalarType<T[P], TestTasksGroupByOutputType[P]>
        }
      >
    >


  export type TestTasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    groupid?: boolean
    description?: boolean
    img?: boolean
    beginningdate?: boolean
    enddatetime?: boolean
    time?: boolean
    teacherid?: boolean
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    questions?: boolean | TestTasks$questionsArgs<ExtArgs>
    _count?: boolean | TestTasksCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTasks"]>

  export type TestTasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    groupid?: boolean
    description?: boolean
    img?: boolean
    beginningdate?: boolean
    enddatetime?: boolean
    time?: boolean
    teacherid?: boolean
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTasks"]>

  export type TestTasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    groupid?: boolean
    description?: boolean
    img?: boolean
    beginningdate?: boolean
    enddatetime?: boolean
    time?: boolean
    teacherid?: boolean
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testTasks"]>

  export type TestTasksSelectScalar = {
    id?: boolean
    title?: boolean
    groupid?: boolean
    description?: boolean
    img?: boolean
    beginningdate?: boolean
    enddatetime?: boolean
    time?: boolean
    teacherid?: boolean
  }

  export type TestTasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "groupid" | "description" | "img" | "beginningdate" | "enddatetime" | "time" | "teacherid", ExtArgs["result"]["testTasks"]>
  export type TestTasksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    questions?: boolean | TestTasks$questionsArgs<ExtArgs>
    _count?: boolean | TestTasksCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestTasksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type TestTasksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | GroupsDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $TestTasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestTasks"
    objects: {
      groups: Prisma.$GroupsPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
      questions: Prisma.$QuestionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      groupid: number
      description: string
      img: string | null
      beginningdate: Date
      enddatetime: Date
      time: number
      teacherid: number
    }, ExtArgs["result"]["testTasks"]>
    composites: {}
  }

  type TestTasksGetPayload<S extends boolean | null | undefined | TestTasksDefaultArgs> = $Result.GetResult<Prisma.$TestTasksPayload, S>

  type TestTasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestTasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestTasksCountAggregateInputType | true
    }

  export interface TestTasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestTasks'], meta: { name: 'TestTasks' } }
    /**
     * Find zero or one TestTasks that matches the filter.
     * @param {TestTasksFindUniqueArgs} args - Arguments to find a TestTasks
     * @example
     * // Get one TestTasks
     * const testTasks = await prisma.testTasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestTasksFindUniqueArgs>(args: SelectSubset<T, TestTasksFindUniqueArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestTasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestTasksFindUniqueOrThrowArgs} args - Arguments to find a TestTasks
     * @example
     * // Get one TestTasks
     * const testTasks = await prisma.testTasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestTasksFindUniqueOrThrowArgs>(args: SelectSubset<T, TestTasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksFindFirstArgs} args - Arguments to find a TestTasks
     * @example
     * // Get one TestTasks
     * const testTasks = await prisma.testTasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestTasksFindFirstArgs>(args?: SelectSubset<T, TestTasksFindFirstArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestTasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksFindFirstOrThrowArgs} args - Arguments to find a TestTasks
     * @example
     * // Get one TestTasks
     * const testTasks = await prisma.testTasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestTasksFindFirstOrThrowArgs>(args?: SelectSubset<T, TestTasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestTasks
     * const testTasks = await prisma.testTasks.findMany()
     * 
     * // Get first 10 TestTasks
     * const testTasks = await prisma.testTasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testTasksWithIdOnly = await prisma.testTasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestTasksFindManyArgs>(args?: SelectSubset<T, TestTasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestTasks.
     * @param {TestTasksCreateArgs} args - Arguments to create a TestTasks.
     * @example
     * // Create one TestTasks
     * const TestTasks = await prisma.testTasks.create({
     *   data: {
     *     // ... data to create a TestTasks
     *   }
     * })
     * 
     */
    create<T extends TestTasksCreateArgs>(args: SelectSubset<T, TestTasksCreateArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestTasks.
     * @param {TestTasksCreateManyArgs} args - Arguments to create many TestTasks.
     * @example
     * // Create many TestTasks
     * const testTasks = await prisma.testTasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestTasksCreateManyArgs>(args?: SelectSubset<T, TestTasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestTasks and returns the data saved in the database.
     * @param {TestTasksCreateManyAndReturnArgs} args - Arguments to create many TestTasks.
     * @example
     * // Create many TestTasks
     * const testTasks = await prisma.testTasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestTasks and only return the `id`
     * const testTasksWithIdOnly = await prisma.testTasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestTasksCreateManyAndReturnArgs>(args?: SelectSubset<T, TestTasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestTasks.
     * @param {TestTasksDeleteArgs} args - Arguments to delete one TestTasks.
     * @example
     * // Delete one TestTasks
     * const TestTasks = await prisma.testTasks.delete({
     *   where: {
     *     // ... filter to delete one TestTasks
     *   }
     * })
     * 
     */
    delete<T extends TestTasksDeleteArgs>(args: SelectSubset<T, TestTasksDeleteArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestTasks.
     * @param {TestTasksUpdateArgs} args - Arguments to update one TestTasks.
     * @example
     * // Update one TestTasks
     * const testTasks = await prisma.testTasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestTasksUpdateArgs>(args: SelectSubset<T, TestTasksUpdateArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestTasks.
     * @param {TestTasksDeleteManyArgs} args - Arguments to filter TestTasks to delete.
     * @example
     * // Delete a few TestTasks
     * const { count } = await prisma.testTasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestTasksDeleteManyArgs>(args?: SelectSubset<T, TestTasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestTasks
     * const testTasks = await prisma.testTasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestTasksUpdateManyArgs>(args: SelectSubset<T, TestTasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestTasks and returns the data updated in the database.
     * @param {TestTasksUpdateManyAndReturnArgs} args - Arguments to update many TestTasks.
     * @example
     * // Update many TestTasks
     * const testTasks = await prisma.testTasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestTasks and only return the `id`
     * const testTasksWithIdOnly = await prisma.testTasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestTasksUpdateManyAndReturnArgs>(args: SelectSubset<T, TestTasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestTasks.
     * @param {TestTasksUpsertArgs} args - Arguments to update or create a TestTasks.
     * @example
     * // Update or create a TestTasks
     * const testTasks = await prisma.testTasks.upsert({
     *   create: {
     *     // ... data to create a TestTasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestTasks we want to update
     *   }
     * })
     */
    upsert<T extends TestTasksUpsertArgs>(args: SelectSubset<T, TestTasksUpsertArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksCountArgs} args - Arguments to filter TestTasks to count.
     * @example
     * // Count the number of TestTasks
     * const count = await prisma.testTasks.count({
     *   where: {
     *     // ... the filter for the TestTasks we want to count
     *   }
     * })
    **/
    count<T extends TestTasksCountArgs>(
      args?: Subset<T, TestTasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestTasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestTasksAggregateArgs>(args: Subset<T, TestTasksAggregateArgs>): Prisma.PrismaPromise<GetTestTasksAggregateType<T>>

    /**
     * Group by TestTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestTasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestTasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestTasksGroupByArgs['orderBy'] }
        : { orderBy?: TestTasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestTasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestTasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestTasks model
   */
  readonly fields: TestTasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestTasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestTasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groups<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends TestTasks$questionsArgs<ExtArgs> = {}>(args?: Subset<T, TestTasks$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestTasks model
   */
  interface TestTasksFieldRefs {
    readonly id: FieldRef<"TestTasks", 'Int'>
    readonly title: FieldRef<"TestTasks", 'String'>
    readonly groupid: FieldRef<"TestTasks", 'Int'>
    readonly description: FieldRef<"TestTasks", 'String'>
    readonly img: FieldRef<"TestTasks", 'String'>
    readonly beginningdate: FieldRef<"TestTasks", 'DateTime'>
    readonly enddatetime: FieldRef<"TestTasks", 'DateTime'>
    readonly time: FieldRef<"TestTasks", 'Int'>
    readonly teacherid: FieldRef<"TestTasks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TestTasks findUnique
   */
  export type TestTasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter, which TestTasks to fetch.
     */
    where: TestTasksWhereUniqueInput
  }

  /**
   * TestTasks findUniqueOrThrow
   */
  export type TestTasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter, which TestTasks to fetch.
     */
    where: TestTasksWhereUniqueInput
  }

  /**
   * TestTasks findFirst
   */
  export type TestTasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter, which TestTasks to fetch.
     */
    where?: TestTasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTasks to fetch.
     */
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTasks.
     */
    cursor?: TestTasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTasks.
     */
    distinct?: TestTasksScalarFieldEnum | TestTasksScalarFieldEnum[]
  }

  /**
   * TestTasks findFirstOrThrow
   */
  export type TestTasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter, which TestTasks to fetch.
     */
    where?: TestTasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTasks to fetch.
     */
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestTasks.
     */
    cursor?: TestTasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestTasks.
     */
    distinct?: TestTasksScalarFieldEnum | TestTasksScalarFieldEnum[]
  }

  /**
   * TestTasks findMany
   */
  export type TestTasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter, which TestTasks to fetch.
     */
    where?: TestTasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestTasks to fetch.
     */
    orderBy?: TestTasksOrderByWithRelationInput | TestTasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestTasks.
     */
    cursor?: TestTasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestTasks.
     */
    skip?: number
    distinct?: TestTasksScalarFieldEnum | TestTasksScalarFieldEnum[]
  }

  /**
   * TestTasks create
   */
  export type TestTasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * The data needed to create a TestTasks.
     */
    data: XOR<TestTasksCreateInput, TestTasksUncheckedCreateInput>
  }

  /**
   * TestTasks createMany
   */
  export type TestTasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestTasks.
     */
    data: TestTasksCreateManyInput | TestTasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestTasks createManyAndReturn
   */
  export type TestTasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * The data used to create many TestTasks.
     */
    data: TestTasksCreateManyInput | TestTasksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestTasks update
   */
  export type TestTasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * The data needed to update a TestTasks.
     */
    data: XOR<TestTasksUpdateInput, TestTasksUncheckedUpdateInput>
    /**
     * Choose, which TestTasks to update.
     */
    where: TestTasksWhereUniqueInput
  }

  /**
   * TestTasks updateMany
   */
  export type TestTasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestTasks.
     */
    data: XOR<TestTasksUpdateManyMutationInput, TestTasksUncheckedUpdateManyInput>
    /**
     * Filter which TestTasks to update
     */
    where?: TestTasksWhereInput
    /**
     * Limit how many TestTasks to update.
     */
    limit?: number
  }

  /**
   * TestTasks updateManyAndReturn
   */
  export type TestTasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * The data used to update TestTasks.
     */
    data: XOR<TestTasksUpdateManyMutationInput, TestTasksUncheckedUpdateManyInput>
    /**
     * Filter which TestTasks to update
     */
    where?: TestTasksWhereInput
    /**
     * Limit how many TestTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestTasks upsert
   */
  export type TestTasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * The filter to search for the TestTasks to update in case it exists.
     */
    where: TestTasksWhereUniqueInput
    /**
     * In case the TestTasks found by the `where` argument doesn't exist, create a new TestTasks with this data.
     */
    create: XOR<TestTasksCreateInput, TestTasksUncheckedCreateInput>
    /**
     * In case the TestTasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestTasksUpdateInput, TestTasksUncheckedUpdateInput>
  }

  /**
   * TestTasks delete
   */
  export type TestTasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
    /**
     * Filter which TestTasks to delete.
     */
    where: TestTasksWhereUniqueInput
  }

  /**
   * TestTasks deleteMany
   */
  export type TestTasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestTasks to delete
     */
    where?: TestTasksWhereInput
    /**
     * Limit how many TestTasks to delete.
     */
    limit?: number
  }

  /**
   * TestTasks.questions
   */
  export type TestTasks$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    where?: QuestionsWhereInput
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    cursor?: QuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * TestTasks without action
   */
  export type TestTasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestTasks
     */
    select?: TestTasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestTasks
     */
    omit?: TestTasksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestTasksInclude<ExtArgs> | null
  }


  /**
   * Model Questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    id: number | null
    testtaskid: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    id: number | null
    testtaskid: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: number | null
    description: string | null
    img: string | null
    testtaskid: number | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: number | null
    description: string | null
    img: string | null
    testtaskid: number | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    description: number
    img: number
    testtaskid: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    id?: true
    testtaskid?: true
  }

  export type QuestionsSumAggregateInputType = {
    id?: true
    testtaskid?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    description?: true
    img?: true
    testtaskid?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    description?: true
    img?: true
    testtaskid?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    description?: true
    img?: true
    testtaskid?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to aggregate.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type QuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsWhereInput
    orderBy?: QuestionsOrderByWithAggregationInput | QuestionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: QuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: number
    description: string
    img: string | null
    testtaskid: number
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends QuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    img?: boolean
    testtaskid?: boolean
    answers?: boolean | Questions$answersArgs<ExtArgs>
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type QuestionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    img?: boolean
    testtaskid?: boolean
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type QuestionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    img?: boolean
    testtaskid?: boolean
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type QuestionsSelectScalar = {
    id?: boolean
    description?: boolean
    img?: boolean
    testtaskid?: boolean
  }

  export type QuestionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "img" | "testtaskid", ExtArgs["result"]["questions"]>
  export type QuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | Questions$answersArgs<ExtArgs>
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
  }
  export type QuestionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testtasks?: boolean | TestTasksDefaultArgs<ExtArgs>
  }

  export type $QuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Questions"
    objects: {
      answers: Prisma.$AnswersPayload<ExtArgs>[]
      testtasks: Prisma.$TestTasksPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      img: string | null
      testtaskid: number
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type QuestionsGetPayload<S extends boolean | null | undefined | QuestionsDefaultArgs> = $Result.GetResult<Prisma.$QuestionsPayload, S>

  type QuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface QuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Questions'], meta: { name: 'Questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {QuestionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionsFindUniqueArgs>(args: SelectSubset<T, QuestionsFindUniqueArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionsFindFirstArgs>(args?: SelectSubset<T, QuestionsFindFirstArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionsFindManyArgs>(args?: SelectSubset<T, QuestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Questions.
     * @param {QuestionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends QuestionsCreateArgs>(args: SelectSubset<T, QuestionsCreateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionsCreateManyArgs>(args?: SelectSubset<T, QuestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionsCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionsCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Questions.
     * @param {QuestionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends QuestionsDeleteArgs>(args: SelectSubset<T, QuestionsDeleteArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Questions.
     * @param {QuestionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionsUpdateArgs>(args: SelectSubset<T, QuestionsUpdateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionsDeleteManyArgs>(args?: SelectSubset<T, QuestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionsUpdateManyArgs>(args: SelectSubset<T, QuestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionsUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionsUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Questions.
     * @param {QuestionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends QuestionsUpsertArgs>(args: SelectSubset<T, QuestionsUpsertArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionsCountArgs>(
      args?: Subset<T, QuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Questions model
   */
  readonly fields: QuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends Questions$answersArgs<ExtArgs> = {}>(args?: Subset<T, Questions$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testtasks<T extends TestTasksDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestTasksDefaultArgs<ExtArgs>>): Prisma__TestTasksClient<$Result.GetResult<Prisma.$TestTasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Questions model
   */
  interface QuestionsFieldRefs {
    readonly id: FieldRef<"Questions", 'Int'>
    readonly description: FieldRef<"Questions", 'String'>
    readonly img: FieldRef<"Questions", 'String'>
    readonly testtaskid: FieldRef<"Questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Questions findUnique
   */
  export type QuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findUniqueOrThrow
   */
  export type QuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findFirst
   */
  export type QuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findFirstOrThrow
   */
  export type QuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findMany
   */
  export type QuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions create
   */
  export type QuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Questions.
     */
    data: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
  }

  /**
   * Questions createMany
   */
  export type QuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionsCreateManyInput | QuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Questions createManyAndReturn
   */
  export type QuestionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionsCreateManyInput | QuestionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Questions update
   */
  export type QuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Questions.
     */
    data: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
    /**
     * Choose, which Questions to update.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions updateMany
   */
  export type QuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionsWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Questions updateManyAndReturn
   */
  export type QuestionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionsWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Questions upsert
   */
  export type QuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Questions to update in case it exists.
     */
    where: QuestionsWhereUniqueInput
    /**
     * In case the Questions found by the `where` argument doesn't exist, create a new Questions with this data.
     */
    create: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
    /**
     * In case the Questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
  }

  /**
   * Questions delete
   */
  export type QuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter which Questions to delete.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions deleteMany
   */
  export type QuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionsWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Questions.answers
   */
  export type Questions$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    cursor?: AnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Questions without action
   */
  export type QuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Questions
     */
    omit?: QuestionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
  }


  /**
   * Model Answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersAvgAggregateOutputType = {
    id: number | null
    questionid: number | null
  }

  export type AnswersSumAggregateOutputType = {
    id: number | null
    questionid: number | null
  }

  export type AnswersMinAggregateOutputType = {
    id: number | null
    questionid: number | null
    text: string | null
    iscorrect: boolean | null
  }

  export type AnswersMaxAggregateOutputType = {
    id: number | null
    questionid: number | null
    text: string | null
    iscorrect: boolean | null
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    questionid: number
    text: number
    iscorrect: number
    _all: number
  }


  export type AnswersAvgAggregateInputType = {
    id?: true
    questionid?: true
  }

  export type AnswersSumAggregateInputType = {
    id?: true
    questionid?: true
  }

  export type AnswersMinAggregateInputType = {
    id?: true
    questionid?: true
    text?: true
    iscorrect?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    questionid?: true
    text?: true
    iscorrect?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    questionid?: true
    text?: true
    iscorrect?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to aggregate.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type AnswersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithAggregationInput | AnswersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: AnswersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _avg?: AnswersAvgAggregateInputType
    _sum?: AnswersSumAggregateInputType
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    id: number
    questionid: number
    text: string
    iscorrect: boolean | null
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends AnswersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type AnswersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionid?: boolean
    text?: boolean
    iscorrect?: boolean
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionid?: boolean
    text?: boolean
    iscorrect?: boolean
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionid?: boolean
    text?: boolean
    iscorrect?: boolean
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectScalar = {
    id?: boolean
    questionid?: boolean
    text?: boolean
    iscorrect?: boolean
  }

  export type AnswersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionid" | "text" | "iscorrect", ExtArgs["result"]["answers"]>
  export type AnswersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }
  export type AnswersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }
  export type AnswersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionsDefaultArgs<ExtArgs>
  }

  export type $AnswersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answers"
    objects: {
      question: Prisma.$QuestionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionid: number
      text: string
      iscorrect: boolean | null
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }

  type AnswersGetPayload<S extends boolean | null | undefined | AnswersDefaultArgs> = $Result.GetResult<Prisma.$AnswersPayload, S>

  type AnswersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnswersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface AnswersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answers'], meta: { name: 'Answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {AnswersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswersFindUniqueArgs>(args: SelectSubset<T, AnswersFindUniqueArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswersFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswersFindFirstArgs>(args?: SelectSubset<T, AnswersFindFirstArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswersFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswersFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswersFindManyArgs>(args?: SelectSubset<T, AnswersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answers.
     * @param {AnswersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
     */
    create<T extends AnswersCreateArgs>(args: SelectSubset<T, AnswersCreateArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {AnswersCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswersCreateManyArgs>(args?: SelectSubset<T, AnswersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswersCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answersWithIdOnly = await prisma.answers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswersCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answers.
     * @param {AnswersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
     */
    delete<T extends AnswersDeleteArgs>(args: SelectSubset<T, AnswersDeleteArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answers.
     * @param {AnswersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswersUpdateArgs>(args: SelectSubset<T, AnswersUpdateArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {AnswersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswersDeleteManyArgs>(args?: SelectSubset<T, AnswersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswersUpdateManyArgs>(args: SelectSubset<T, AnswersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers and returns the data updated in the database.
     * @param {AnswersUpdateManyAndReturnArgs} args - Arguments to update many Answers.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answers and only return the `id`
     * const answersWithIdOnly = await prisma.answers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnswersUpdateManyAndReturnArgs>(args: SelectSubset<T, AnswersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answers.
     * @param {AnswersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
     */
    upsert<T extends AnswersUpsertArgs>(args: SelectSubset<T, AnswersUpsertArgs<ExtArgs>>): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswersCountArgs>(
      args?: Subset<T, AnswersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswersGroupByArgs['orderBy'] }
        : { orderBy?: AnswersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answers model
   */
  readonly fields: AnswersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsDefaultArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answers model
   */
  interface AnswersFieldRefs {
    readonly id: FieldRef<"Answers", 'Int'>
    readonly questionid: FieldRef<"Answers", 'Int'>
    readonly text: FieldRef<"Answers", 'String'>
    readonly iscorrect: FieldRef<"Answers", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Answers findUnique
   */
  export type AnswersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers findUniqueOrThrow
   */
  export type AnswersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers findFirst
   */
  export type AnswersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers findFirstOrThrow
   */
  export type AnswersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers findMany
   */
  export type AnswersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * Answers create
   */
  export type AnswersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to create a Answers.
     */
    data: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
  }

  /**
   * Answers createMany
   */
  export type AnswersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswersCreateManyInput | AnswersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answers createManyAndReturn
   */
  export type AnswersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswersCreateManyInput | AnswersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answers update
   */
  export type AnswersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to update a Answers.
     */
    data: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
    /**
     * Choose, which Answers to update.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers updateMany
   */
  export type AnswersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswersWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
  }

  /**
   * Answers updateManyAndReturn
   */
  export type AnswersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswersWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answers upsert
   */
  export type AnswersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The filter to search for the Answers to update in case it exists.
     */
    where: AnswersWhereUniqueInput
    /**
     * In case the Answers found by the `where` argument doesn't exist, create a new Answers with this data.
     */
    create: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
    /**
     * In case the Answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
  }

  /**
   * Answers delete
   */
  export type AnswersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter which Answers to delete.
     */
    where: AnswersWhereUniqueInput
  }

  /**
   * Answers deleteMany
   */
  export type AnswersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswersWhereInput
    /**
     * Limit how many Answers to delete.
     */
    limit?: number
  }

  /**
   * Answers without action
   */
  export type AnswersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answers
     */
    omit?: AnswersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswersInclude<ExtArgs> | null
  }


  /**
   * Model Grades
   */

  export type AggregateGrades = {
    _count: GradesCountAggregateOutputType | null
    _avg: GradesAvgAggregateOutputType | null
    _sum: GradesSumAggregateOutputType | null
    _min: GradesMinAggregateOutputType | null
    _max: GradesMaxAggregateOutputType | null
  }

  export type GradesAvgAggregateOutputType = {
    id: number | null
    studentid: number | null
    grade: number | null
  }

  export type GradesSumAggregateOutputType = {
    id: number | null
    studentid: number | null
    grade: number | null
  }

  export type GradesMinAggregateOutputType = {
    id: number | null
    studentid: number | null
    grade: number | null
    date: Date | null
  }

  export type GradesMaxAggregateOutputType = {
    id: number | null
    studentid: number | null
    grade: number | null
    date: Date | null
  }

  export type GradesCountAggregateOutputType = {
    id: number
    studentid: number
    grade: number
    date: number
    _all: number
  }


  export type GradesAvgAggregateInputType = {
    id?: true
    studentid?: true
    grade?: true
  }

  export type GradesSumAggregateInputType = {
    id?: true
    studentid?: true
    grade?: true
  }

  export type GradesMinAggregateInputType = {
    id?: true
    studentid?: true
    grade?: true
    date?: true
  }

  export type GradesMaxAggregateInputType = {
    id?: true
    studentid?: true
    grade?: true
    date?: true
  }

  export type GradesCountAggregateInputType = {
    id?: true
    studentid?: true
    grade?: true
    date?: true
    _all?: true
  }

  export type GradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to aggregate.
     */
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradesOrderByWithRelationInput | GradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradesMaxAggregateInputType
  }

  export type GetGradesAggregateType<T extends GradesAggregateArgs> = {
        [P in keyof T & keyof AggregateGrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrades[P]>
      : GetScalarType<T[P], AggregateGrades[P]>
  }




  export type GradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradesWhereInput
    orderBy?: GradesOrderByWithAggregationInput | GradesOrderByWithAggregationInput[]
    by: GradesScalarFieldEnum[] | GradesScalarFieldEnum
    having?: GradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradesCountAggregateInputType | true
    _avg?: GradesAvgAggregateInputType
    _sum?: GradesSumAggregateInputType
    _min?: GradesMinAggregateInputType
    _max?: GradesMaxAggregateInputType
  }

  export type GradesGroupByOutputType = {
    id: number
    studentid: number
    grade: number
    date: Date
    _count: GradesCountAggregateOutputType | null
    _avg: GradesAvgAggregateOutputType | null
    _sum: GradesSumAggregateOutputType | null
    _min: GradesMinAggregateOutputType | null
    _max: GradesMaxAggregateOutputType | null
  }

  type GetGradesGroupByPayload<T extends GradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradesGroupByOutputType[P]>
            : GetScalarType<T[P], GradesGroupByOutputType[P]>
        }
      >
    >


  export type GradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentid?: boolean
    grade?: boolean
    date?: boolean
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type GradesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentid?: boolean
    grade?: boolean
    date?: boolean
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type GradesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentid?: boolean
    grade?: boolean
    date?: boolean
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grades"]>

  export type GradesSelectScalar = {
    id?: boolean
    studentid?: boolean
    grade?: boolean
    date?: boolean
  }

  export type GradesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentid" | "grade" | "date", ExtArgs["result"]["grades"]>
  export type GradesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type GradesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }
  export type GradesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | StudentsDefaultArgs<ExtArgs>
  }

  export type $GradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grades"
    objects: {
      students: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentid: number
      grade: number
      date: Date
    }, ExtArgs["result"]["grades"]>
    composites: {}
  }

  type GradesGetPayload<S extends boolean | null | undefined | GradesDefaultArgs> = $Result.GetResult<Prisma.$GradesPayload, S>

  type GradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradesCountAggregateInputType | true
    }

  export interface GradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grades'], meta: { name: 'Grades' } }
    /**
     * Find zero or one Grades that matches the filter.
     * @param {GradesFindUniqueArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradesFindUniqueArgs>(args: SelectSubset<T, GradesFindUniqueArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradesFindUniqueOrThrowArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradesFindUniqueOrThrowArgs>(args: SelectSubset<T, GradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesFindFirstArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradesFindFirstArgs>(args?: SelectSubset<T, GradesFindFirstArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesFindFirstOrThrowArgs} args - Arguments to find a Grades
     * @example
     * // Get one Grades
     * const grades = await prisma.grades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradesFindFirstOrThrowArgs>(args?: SelectSubset<T, GradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grades.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradesWithIdOnly = await prisma.grades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradesFindManyArgs>(args?: SelectSubset<T, GradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grades.
     * @param {GradesCreateArgs} args - Arguments to create a Grades.
     * @example
     * // Create one Grades
     * const Grades = await prisma.grades.create({
     *   data: {
     *     // ... data to create a Grades
     *   }
     * })
     * 
     */
    create<T extends GradesCreateArgs>(args: SelectSubset<T, GradesCreateArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradesCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grades = await prisma.grades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradesCreateManyArgs>(args?: SelectSubset<T, GradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradesCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grades = await prisma.grades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradesWithIdOnly = await prisma.grades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradesCreateManyAndReturnArgs>(args?: SelectSubset<T, GradesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grades.
     * @param {GradesDeleteArgs} args - Arguments to delete one Grades.
     * @example
     * // Delete one Grades
     * const Grades = await prisma.grades.delete({
     *   where: {
     *     // ... filter to delete one Grades
     *   }
     * })
     * 
     */
    delete<T extends GradesDeleteArgs>(args: SelectSubset<T, GradesDeleteArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grades.
     * @param {GradesUpdateArgs} args - Arguments to update one Grades.
     * @example
     * // Update one Grades
     * const grades = await prisma.grades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradesUpdateArgs>(args: SelectSubset<T, GradesUpdateArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradesDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradesDeleteManyArgs>(args?: SelectSubset<T, GradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grades = await prisma.grades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradesUpdateManyArgs>(args: SelectSubset<T, GradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradesUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grades = await prisma.grades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradesWithIdOnly = await prisma.grades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradesUpdateManyAndReturnArgs>(args: SelectSubset<T, GradesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grades.
     * @param {GradesUpsertArgs} args - Arguments to update or create a Grades.
     * @example
     * // Update or create a Grades
     * const grades = await prisma.grades.upsert({
     *   create: {
     *     // ... data to create a Grades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grades we want to update
     *   }
     * })
     */
    upsert<T extends GradesUpsertArgs>(args: SelectSubset<T, GradesUpsertArgs<ExtArgs>>): Prisma__GradesClient<$Result.GetResult<Prisma.$GradesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grades.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradesCountArgs>(
      args?: Subset<T, GradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradesAggregateArgs>(args: Subset<T, GradesAggregateArgs>): Prisma.PrismaPromise<GetGradesAggregateType<T>>

    /**
     * Group by Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradesGroupByArgs['orderBy'] }
        : { orderBy?: GradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grades model
   */
  readonly fields: GradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grades model
   */
  interface GradesFieldRefs {
    readonly id: FieldRef<"Grades", 'Int'>
    readonly studentid: FieldRef<"Grades", 'Int'>
    readonly grade: FieldRef<"Grades", 'Int'>
    readonly date: FieldRef<"Grades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grades findUnique
   */
  export type GradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where: GradesWhereUniqueInput
  }

  /**
   * Grades findUniqueOrThrow
   */
  export type GradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where: GradesWhereUniqueInput
  }

  /**
   * Grades findFirst
   */
  export type GradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradesOrderByWithRelationInput | GradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * Grades findFirstOrThrow
   */
  export type GradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradesOrderByWithRelationInput | GradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * Grades findMany
   */
  export type GradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradesOrderByWithRelationInput | GradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradesScalarFieldEnum | GradesScalarFieldEnum[]
  }

  /**
   * Grades create
   */
  export type GradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * The data needed to create a Grades.
     */
    data: XOR<GradesCreateInput, GradesUncheckedCreateInput>
  }

  /**
   * Grades createMany
   */
  export type GradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradesCreateManyInput | GradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grades createManyAndReturn
   */
  export type GradesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradesCreateManyInput | GradesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grades update
   */
  export type GradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * The data needed to update a Grades.
     */
    data: XOR<GradesUpdateInput, GradesUncheckedUpdateInput>
    /**
     * Choose, which Grades to update.
     */
    where: GradesWhereUniqueInput
  }

  /**
   * Grades updateMany
   */
  export type GradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradesUpdateManyMutationInput, GradesUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradesWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grades updateManyAndReturn
   */
  export type GradesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradesUpdateManyMutationInput, GradesUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradesWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grades upsert
   */
  export type GradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * The filter to search for the Grades to update in case it exists.
     */
    where: GradesWhereUniqueInput
    /**
     * In case the Grades found by the `where` argument doesn't exist, create a new Grades with this data.
     */
    create: XOR<GradesCreateInput, GradesUncheckedCreateInput>
    /**
     * In case the Grades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradesUpdateInput, GradesUncheckedUpdateInput>
  }

  /**
   * Grades delete
   */
  export type GradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
    /**
     * Filter which Grades to delete.
     */
    where: GradesWhereUniqueInput
  }

  /**
   * Grades deleteMany
   */
  export type GradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradesWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grades without action
   */
  export type GradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grades
     */
    select?: GradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grades
     */
    omit?: GradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    passwordhash: 'passwordhash',
    login: 'login',
    date: 'date',
    roleid: 'roleid'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastname: 'lastname',
    patronymic: 'patronymic',
    userid: 'userid'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    course: 'course'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    lastname: 'lastname',
    patronymic: 'patronymic',
    userId: 'userId',
    groupId: 'groupId'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const TeacherGroupsScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    groupId: 'groupId'
  };

  export type TeacherGroupsScalarFieldEnum = (typeof TeacherGroupsScalarFieldEnum)[keyof typeof TeacherGroupsScalarFieldEnum]


  export const TestTasksScalarFieldEnum: {
    id: 'id',
    title: 'title',
    groupid: 'groupid',
    description: 'description',
    img: 'img',
    beginningdate: 'beginningdate',
    enddatetime: 'enddatetime',
    time: 'time',
    teacherid: 'teacherid'
  };

  export type TestTasksScalarFieldEnum = (typeof TestTasksScalarFieldEnum)[keyof typeof TestTasksScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    img: 'img',
    testtaskid: 'testtaskid'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const AnswersScalarFieldEnum: {
    id: 'id',
    questionid: 'questionid',
    text: 'text',
    iscorrect: 'iscorrect'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const GradesScalarFieldEnum: {
    id: 'id',
    studentid: 'studentid',
    grade: 'grade',
    date: 'date'
  };

  export type GradesScalarFieldEnum = (typeof GradesScalarFieldEnum)[keyof typeof GradesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    title?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserListRelationFilter
  }, "id" | "title">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    title?: StringWithAggregatesFilter<"Role"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    passwordhash?: StringFilter<"User"> | string
    login?: StringFilter<"User"> | string
    date?: DateTimeFilter<"User"> | Date | string
    roleid?: IntFilter<"User"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    teachers?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    passwordhash?: SortOrder
    login?: SortOrder
    date?: SortOrder
    roleid?: SortOrder
    role?: RoleOrderByWithRelationInput
    teachers?: TeacherOrderByWithRelationInput
    students?: StudentsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    login?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordhash?: StringFilter<"User"> | string
    date?: DateTimeFilter<"User"> | Date | string
    roleid?: IntFilter<"User"> | number
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    teachers?: XOR<TeacherNullableScalarRelationFilter, TeacherWhereInput> | null
    students?: StudentsListRelationFilter
  }, "id" | "login">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    passwordhash?: SortOrder
    login?: SortOrder
    date?: SortOrder
    roleid?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    passwordhash?: StringWithAggregatesFilter<"User"> | string
    login?: StringWithAggregatesFilter<"User"> | string
    date?: DateTimeWithAggregatesFilter<"User"> | Date | string
    roleid?: IntWithAggregatesFilter<"User"> | number
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: IntFilter<"Teacher"> | number
    name?: StringFilter<"Teacher"> | string
    lastname?: StringFilter<"Teacher"> | string
    patronymic?: StringFilter<"Teacher"> | string
    userid?: IntFilter<"Teacher"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    teacherGroups?: TeacherGroupsListRelationFilter
    testTasks?: TestTasksListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userid?: SortOrder
    users?: UserOrderByWithRelationInput
    teacherGroups?: TeacherGroupsOrderByRelationAggregateInput
    testTasks?: TestTasksOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userid?: number
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    name?: StringFilter<"Teacher"> | string
    lastname?: StringFilter<"Teacher"> | string
    patronymic?: StringFilter<"Teacher"> | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    teacherGroups?: TeacherGroupsListRelationFilter
    testTasks?: TestTasksListRelationFilter
  }, "id" | "userid">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userid?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _avg?: TeacherAvgOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
    _sum?: TeacherSumOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teacher"> | number
    name?: StringWithAggregatesFilter<"Teacher"> | string
    lastname?: StringWithAggregatesFilter<"Teacher"> | string
    patronymic?: StringWithAggregatesFilter<"Teacher"> | string
    userid?: IntWithAggregatesFilter<"Teacher"> | number
  }

  export type GroupsWhereInput = {
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    id?: IntFilter<"Groups"> | number
    title?: StringFilter<"Groups"> | string
    course?: IntFilter<"Groups"> | number
    students?: StudentsListRelationFilter
    teacherGroups?: TeacherGroupsListRelationFilter
    testTasks?: TestTasksListRelationFilter
  }

  export type GroupsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    course?: SortOrder
    students?: StudentsOrderByRelationAggregateInput
    teacherGroups?: TeacherGroupsOrderByRelationAggregateInput
    testTasks?: TestTasksOrderByRelationAggregateInput
  }

  export type GroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    title?: StringFilter<"Groups"> | string
    course?: IntFilter<"Groups"> | number
    students?: StudentsListRelationFilter
    teacherGroups?: TeacherGroupsListRelationFilter
    testTasks?: TestTasksListRelationFilter
  }, "id">

  export type GroupsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    course?: SortOrder
    _count?: GroupsCountOrderByAggregateInput
    _avg?: GroupsAvgOrderByAggregateInput
    _max?: GroupsMaxOrderByAggregateInput
    _min?: GroupsMinOrderByAggregateInput
    _sum?: GroupsSumOrderByAggregateInput
  }

  export type GroupsScalarWhereWithAggregatesInput = {
    AND?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    OR?: GroupsScalarWhereWithAggregatesInput[]
    NOT?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Groups"> | number
    title?: StringWithAggregatesFilter<"Groups"> | string
    course?: IntWithAggregatesFilter<"Groups"> | number
  }

  export type StudentsWhereInput = {
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    id?: IntFilter<"Students"> | number
    name?: StringFilter<"Students"> | string
    lastname?: StringFilter<"Students"> | string
    patronymic?: StringFilter<"Students"> | string
    userId?: IntFilter<"Students"> | number
    groupId?: IntFilter<"Students"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
    grades?: GradesListRelationFilter
  }

  export type StudentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    users?: UserOrderByWithRelationInput
    group?: GroupsOrderByWithRelationInput
    grades?: GradesOrderByRelationAggregateInput
  }

  export type StudentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    name?: StringFilter<"Students"> | string
    lastname?: StringFilter<"Students"> | string
    patronymic?: StringFilter<"Students"> | string
    groupId?: IntFilter<"Students"> | number
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
    grades?: GradesListRelationFilter
  }, "id" | "userId">

  export type StudentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    _count?: StudentsCountOrderByAggregateInput
    _avg?: StudentsAvgOrderByAggregateInput
    _max?: StudentsMaxOrderByAggregateInput
    _min?: StudentsMinOrderByAggregateInput
    _sum?: StudentsSumOrderByAggregateInput
  }

  export type StudentsScalarWhereWithAggregatesInput = {
    AND?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    OR?: StudentsScalarWhereWithAggregatesInput[]
    NOT?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Students"> | number
    name?: StringWithAggregatesFilter<"Students"> | string
    lastname?: StringWithAggregatesFilter<"Students"> | string
    patronymic?: StringWithAggregatesFilter<"Students"> | string
    userId?: IntWithAggregatesFilter<"Students"> | number
    groupId?: IntWithAggregatesFilter<"Students"> | number
  }

  export type TeacherGroupsWhereInput = {
    AND?: TeacherGroupsWhereInput | TeacherGroupsWhereInput[]
    OR?: TeacherGroupsWhereInput[]
    NOT?: TeacherGroupsWhereInput | TeacherGroupsWhereInput[]
    id?: IntFilter<"TeacherGroups"> | number
    teacherId?: IntFilter<"TeacherGroups"> | number
    groupId?: IntFilter<"TeacherGroups"> | number
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    group?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
  }

  export type TeacherGroupsOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    group?: GroupsOrderByWithRelationInput
  }

  export type TeacherGroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeacherGroupsWhereInput | TeacherGroupsWhereInput[]
    OR?: TeacherGroupsWhereInput[]
    NOT?: TeacherGroupsWhereInput | TeacherGroupsWhereInput[]
    teacherId?: IntFilter<"TeacherGroups"> | number
    groupId?: IntFilter<"TeacherGroups"> | number
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    group?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
  }, "id">

  export type TeacherGroupsOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
    _count?: TeacherGroupsCountOrderByAggregateInput
    _avg?: TeacherGroupsAvgOrderByAggregateInput
    _max?: TeacherGroupsMaxOrderByAggregateInput
    _min?: TeacherGroupsMinOrderByAggregateInput
    _sum?: TeacherGroupsSumOrderByAggregateInput
  }

  export type TeacherGroupsScalarWhereWithAggregatesInput = {
    AND?: TeacherGroupsScalarWhereWithAggregatesInput | TeacherGroupsScalarWhereWithAggregatesInput[]
    OR?: TeacherGroupsScalarWhereWithAggregatesInput[]
    NOT?: TeacherGroupsScalarWhereWithAggregatesInput | TeacherGroupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherGroups"> | number
    teacherId?: IntWithAggregatesFilter<"TeacherGroups"> | number
    groupId?: IntWithAggregatesFilter<"TeacherGroups"> | number
  }

  export type TestTasksWhereInput = {
    AND?: TestTasksWhereInput | TestTasksWhereInput[]
    OR?: TestTasksWhereInput[]
    NOT?: TestTasksWhereInput | TestTasksWhereInput[]
    id?: IntFilter<"TestTasks"> | number
    title?: StringFilter<"TestTasks"> | string
    groupid?: IntFilter<"TestTasks"> | number
    description?: StringFilter<"TestTasks"> | string
    img?: StringNullableFilter<"TestTasks"> | string | null
    beginningdate?: DateTimeFilter<"TestTasks"> | Date | string
    enddatetime?: DateTimeFilter<"TestTasks"> | Date | string
    time?: IntFilter<"TestTasks"> | number
    teacherid?: IntFilter<"TestTasks"> | number
    groups?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    questions?: QuestionsListRelationFilter
  }

  export type TestTasksOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    groupid?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    beginningdate?: SortOrder
    enddatetime?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
    groups?: GroupsOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    questions?: QuestionsOrderByRelationAggregateInput
  }

  export type TestTasksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TestTasksWhereInput | TestTasksWhereInput[]
    OR?: TestTasksWhereInput[]
    NOT?: TestTasksWhereInput | TestTasksWhereInput[]
    title?: StringFilter<"TestTasks"> | string
    groupid?: IntFilter<"TestTasks"> | number
    description?: StringFilter<"TestTasks"> | string
    img?: StringNullableFilter<"TestTasks"> | string | null
    beginningdate?: DateTimeFilter<"TestTasks"> | Date | string
    enddatetime?: DateTimeFilter<"TestTasks"> | Date | string
    time?: IntFilter<"TestTasks"> | number
    teacherid?: IntFilter<"TestTasks"> | number
    groups?: XOR<GroupsScalarRelationFilter, GroupsWhereInput>
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    questions?: QuestionsListRelationFilter
  }, "id">

  export type TestTasksOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    groupid?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    beginningdate?: SortOrder
    enddatetime?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
    _count?: TestTasksCountOrderByAggregateInput
    _avg?: TestTasksAvgOrderByAggregateInput
    _max?: TestTasksMaxOrderByAggregateInput
    _min?: TestTasksMinOrderByAggregateInput
    _sum?: TestTasksSumOrderByAggregateInput
  }

  export type TestTasksScalarWhereWithAggregatesInput = {
    AND?: TestTasksScalarWhereWithAggregatesInput | TestTasksScalarWhereWithAggregatesInput[]
    OR?: TestTasksScalarWhereWithAggregatesInput[]
    NOT?: TestTasksScalarWhereWithAggregatesInput | TestTasksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TestTasks"> | number
    title?: StringWithAggregatesFilter<"TestTasks"> | string
    groupid?: IntWithAggregatesFilter<"TestTasks"> | number
    description?: StringWithAggregatesFilter<"TestTasks"> | string
    img?: StringNullableWithAggregatesFilter<"TestTasks"> | string | null
    beginningdate?: DateTimeWithAggregatesFilter<"TestTasks"> | Date | string
    enddatetime?: DateTimeWithAggregatesFilter<"TestTasks"> | Date | string
    time?: IntWithAggregatesFilter<"TestTasks"> | number
    teacherid?: IntWithAggregatesFilter<"TestTasks"> | number
  }

  export type QuestionsWhereInput = {
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    id?: IntFilter<"Questions"> | number
    description?: StringFilter<"Questions"> | string
    img?: StringNullableFilter<"Questions"> | string | null
    testtaskid?: IntFilter<"Questions"> | number
    answers?: AnswersListRelationFilter
    testtasks?: XOR<TestTasksScalarRelationFilter, TestTasksWhereInput>
  }

  export type QuestionsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    testtaskid?: SortOrder
    answers?: AnswersOrderByRelationAggregateInput
    testtasks?: TestTasksOrderByWithRelationInput
  }

  export type QuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    description?: StringFilter<"Questions"> | string
    img?: StringNullableFilter<"Questions"> | string | null
    testtaskid?: IntFilter<"Questions"> | number
    answers?: AnswersListRelationFilter
    testtasks?: XOR<TestTasksScalarRelationFilter, TestTasksWhereInput>
  }, "id">

  export type QuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    testtaskid?: SortOrder
    _count?: QuestionsCountOrderByAggregateInput
    _avg?: QuestionsAvgOrderByAggregateInput
    _max?: QuestionsMaxOrderByAggregateInput
    _min?: QuestionsMinOrderByAggregateInput
    _sum?: QuestionsSumOrderByAggregateInput
  }

  export type QuestionsScalarWhereWithAggregatesInput = {
    AND?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    OR?: QuestionsScalarWhereWithAggregatesInput[]
    NOT?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Questions"> | number
    description?: StringWithAggregatesFilter<"Questions"> | string
    img?: StringNullableWithAggregatesFilter<"Questions"> | string | null
    testtaskid?: IntWithAggregatesFilter<"Questions"> | number
  }

  export type AnswersWhereInput = {
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    id?: IntFilter<"Answers"> | number
    questionid?: IntFilter<"Answers"> | number
    text?: StringFilter<"Answers"> | string
    iscorrect?: BoolNullableFilter<"Answers"> | boolean | null
    question?: XOR<QuestionsScalarRelationFilter, QuestionsWhereInput>
  }

  export type AnswersOrderByWithRelationInput = {
    id?: SortOrder
    questionid?: SortOrder
    text?: SortOrder
    iscorrect?: SortOrderInput | SortOrder
    question?: QuestionsOrderByWithRelationInput
  }

  export type AnswersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    questionid?: IntFilter<"Answers"> | number
    text?: StringFilter<"Answers"> | string
    iscorrect?: BoolNullableFilter<"Answers"> | boolean | null
    question?: XOR<QuestionsScalarRelationFilter, QuestionsWhereInput>
  }, "id">

  export type AnswersOrderByWithAggregationInput = {
    id?: SortOrder
    questionid?: SortOrder
    text?: SortOrder
    iscorrect?: SortOrderInput | SortOrder
    _count?: AnswersCountOrderByAggregateInput
    _avg?: AnswersAvgOrderByAggregateInput
    _max?: AnswersMaxOrderByAggregateInput
    _min?: AnswersMinOrderByAggregateInput
    _sum?: AnswersSumOrderByAggregateInput
  }

  export type AnswersScalarWhereWithAggregatesInput = {
    AND?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    OR?: AnswersScalarWhereWithAggregatesInput[]
    NOT?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Answers"> | number
    questionid?: IntWithAggregatesFilter<"Answers"> | number
    text?: StringWithAggregatesFilter<"Answers"> | string
    iscorrect?: BoolNullableWithAggregatesFilter<"Answers"> | boolean | null
  }

  export type GradesWhereInput = {
    AND?: GradesWhereInput | GradesWhereInput[]
    OR?: GradesWhereInput[]
    NOT?: GradesWhereInput | GradesWhereInput[]
    id?: IntFilter<"Grades"> | number
    studentid?: IntFilter<"Grades"> | number
    grade?: IntFilter<"Grades"> | number
    date?: DateTimeFilter<"Grades"> | Date | string
    students?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }

  export type GradesOrderByWithRelationInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
    date?: SortOrder
    students?: StudentsOrderByWithRelationInput
  }

  export type GradesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GradesWhereInput | GradesWhereInput[]
    OR?: GradesWhereInput[]
    NOT?: GradesWhereInput | GradesWhereInput[]
    studentid?: IntFilter<"Grades"> | number
    grade?: IntFilter<"Grades"> | number
    date?: DateTimeFilter<"Grades"> | Date | string
    students?: XOR<StudentsScalarRelationFilter, StudentsWhereInput>
  }, "id">

  export type GradesOrderByWithAggregationInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
    date?: SortOrder
    _count?: GradesCountOrderByAggregateInput
    _avg?: GradesAvgOrderByAggregateInput
    _max?: GradesMaxOrderByAggregateInput
    _min?: GradesMinOrderByAggregateInput
    _sum?: GradesSumOrderByAggregateInput
  }

  export type GradesScalarWhereWithAggregatesInput = {
    AND?: GradesScalarWhereWithAggregatesInput | GradesScalarWhereWithAggregatesInput[]
    OR?: GradesScalarWhereWithAggregatesInput[]
    NOT?: GradesScalarWhereWithAggregatesInput | GradesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Grades"> | number
    studentid?: IntWithAggregatesFilter<"Grades"> | number
    grade?: IntWithAggregatesFilter<"Grades"> | number
    date?: DateTimeWithAggregatesFilter<"Grades"> | Date | string
  }

  export type RoleCreateInput = {
    title: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    title: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    title: string
  }

  export type RoleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    passwordhash: string
    login: string
    date?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    teachers?: TeacherCreateNestedOneWithoutUsersInput
    students?: StudentsCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
    roleid: number
    teachers?: TeacherUncheckedCreateNestedOneWithoutUsersInput
    students?: StudentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    teachers?: TeacherUpdateOneWithoutUsersNestedInput
    students?: StudentsUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roleid?: IntFieldUpdateOperationsInput | number
    teachers?: TeacherUncheckedUpdateOneWithoutUsersNestedInput
    students?: StudentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
    roleid: number
  }

  export type UserUpdateManyMutationInput = {
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roleid?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherCreateInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutTeachersInput
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutTeacherInput
    testTasks?: TestTasksCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userid: number
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutTeacherInput
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutTeachersNestedInput
    teacherGroups?: TeacherGroupsUpdateManyWithoutTeacherNestedInput
    testTasks?: TestTasksUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutTeacherNestedInput
    testTasks?: TestTasksUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userid: number
  }

  export type TeacherUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
  }

  export type GroupsCreateInput = {
    title: string
    course: number
    students?: StudentsCreateNestedManyWithoutGroupInput
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateInput = {
    id?: number
    title: string
    course: number
    students?: StudentsUncheckedCreateNestedManyWithoutGroupInput
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUpdateManyWithoutGroupNestedInput
    teacherGroups?: TeacherGroupsUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUncheckedUpdateManyWithoutGroupNestedInput
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsCreateManyInput = {
    id?: number
    title: string
    course: number
  }

  export type GroupsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
  }

  export type GroupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
  }

  export type StudentsCreateInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutStudentsInput
    group: GroupsCreateNestedOneWithoutStudentsInput
    grades?: GradesCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userId: number
    groupId: number
    grades?: GradesUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutStudentsNestedInput
    group?: GroupsUpdateOneRequiredWithoutStudentsNestedInput
    grades?: GradesUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    grades?: GradesUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsCreateManyInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userId: number
    groupId: number
  }

  export type StudentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
  }

  export type StudentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsCreateInput = {
    teacher: TeacherCreateNestedOneWithoutTeacherGroupsInput
    group: GroupsCreateNestedOneWithoutTeacherGroupsInput
  }

  export type TeacherGroupsUncheckedCreateInput = {
    id?: number
    teacherId: number
    groupId: number
  }

  export type TeacherGroupsUpdateInput = {
    teacher?: TeacherUpdateOneRequiredWithoutTeacherGroupsNestedInput
    group?: GroupsUpdateOneRequiredWithoutTeacherGroupsNestedInput
  }

  export type TeacherGroupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsCreateManyInput = {
    id?: number
    teacherId: number
    groupId: number
  }

  export type TeacherGroupsUpdateManyMutationInput = {

  }

  export type TeacherGroupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTasksCreateInput = {
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    groups: GroupsCreateNestedOneWithoutTestTasksInput
    teacher: TeacherCreateNestedOneWithoutTestTasksInput
    questions?: QuestionsCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksUncheckedCreateInput = {
    id?: number
    title: string
    groupid: number
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacherid: number
    questions?: QuestionsUncheckedCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    groups?: GroupsUpdateOneRequiredWithoutTestTasksNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTestTasksNestedInput
    questions?: QuestionsUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    groupid?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacherid?: IntFieldUpdateOperationsInput | number
    questions?: QuestionsUncheckedUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksCreateManyInput = {
    id?: number
    title: string
    groupid: number
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacherid: number
  }

  export type TestTasksUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type TestTasksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    groupid?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacherid?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsCreateInput = {
    description: string
    img?: string | null
    answers?: AnswersCreateNestedManyWithoutQuestionInput
    testtasks: TestTasksCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateInput = {
    id?: number
    description: string
    img?: string | null
    testtaskid: number
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswersUpdateManyWithoutQuestionNestedInput
    testtasks?: TestTasksUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    testtaskid?: IntFieldUpdateOperationsInput | number
    answers?: AnswersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsCreateManyInput = {
    id?: number
    description: string
    img?: string | null
    testtaskid: number
  }

  export type QuestionsUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    testtaskid?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersCreateInput = {
    text: string
    iscorrect?: boolean | null
    question: QuestionsCreateNestedOneWithoutAnswersInput
  }

  export type AnswersUncheckedCreateInput = {
    id?: number
    questionid: number
    text: string
    iscorrect?: boolean | null
  }

  export type AnswersUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    question?: QuestionsUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionid?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnswersCreateManyInput = {
    id?: number
    questionid: number
    text: string
    iscorrect?: boolean | null
  }

  export type AnswersUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnswersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionid?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GradesCreateInput = {
    grade: number
    date: Date | string
    students: StudentsCreateNestedOneWithoutGradesInput
  }

  export type GradesUncheckedCreateInput = {
    id?: number
    studentid: number
    grade: number
    date: Date | string
  }

  export type GradesUpdateInput = {
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentsUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentid?: IntFieldUpdateOperationsInput | number
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradesCreateManyInput = {
    id?: number
    studentid: number
    grade: number
    date: Date | string
  }

  export type GradesUpdateManyMutationInput = {
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentid?: IntFieldUpdateOperationsInput | number
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type StudentsListRelationFilter = {
    every?: StudentsWhereInput
    some?: StudentsWhereInput
    none?: StudentsWhereInput
  }

  export type StudentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    passwordhash?: SortOrder
    login?: SortOrder
    date?: SortOrder
    roleid?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    passwordhash?: SortOrder
    login?: SortOrder
    date?: SortOrder
    roleid?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    passwordhash?: SortOrder
    login?: SortOrder
    date?: SortOrder
    roleid?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleid?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeacherGroupsListRelationFilter = {
    every?: TeacherGroupsWhereInput
    some?: TeacherGroupsWhereInput
    none?: TeacherGroupsWhereInput
  }

  export type TestTasksListRelationFilter = {
    every?: TestTasksWhereInput
    some?: TestTasksWhereInput
    none?: TestTasksWhereInput
  }

  export type TeacherGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestTasksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userid?: SortOrder
  }

  export type TeacherAvgOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userid?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userid?: SortOrder
  }

  export type TeacherSumOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
  }

  export type GroupsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    course?: SortOrder
  }

  export type GroupsAvgOrderByAggregateInput = {
    id?: SortOrder
    course?: SortOrder
  }

  export type GroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    course?: SortOrder
  }

  export type GroupsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    course?: SortOrder
  }

  export type GroupsSumOrderByAggregateInput = {
    id?: SortOrder
    course?: SortOrder
  }

  export type GroupsScalarRelationFilter = {
    is?: GroupsWhereInput
    isNot?: GroupsWhereInput
  }

  export type GradesListRelationFilter = {
    every?: GradesWhereInput
    some?: GradesWhereInput
    none?: GradesWhereInput
  }

  export type GradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type StudentsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type StudentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type StudentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    lastname?: SortOrder
    patronymic?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type StudentsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type TeacherGroupsCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
  }

  export type TeacherGroupsAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
  }

  export type TeacherGroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
  }

  export type TeacherGroupsMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
  }

  export type TeacherGroupsSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    groupId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type QuestionsListRelationFilter = {
    every?: QuestionsWhereInput
    some?: QuestionsWhereInput
    none?: QuestionsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QuestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestTasksCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupid?: SortOrder
    description?: SortOrder
    img?: SortOrder
    beginningdate?: SortOrder
    enddatetime?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
  }

  export type TestTasksAvgOrderByAggregateInput = {
    id?: SortOrder
    groupid?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
  }

  export type TestTasksMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupid?: SortOrder
    description?: SortOrder
    img?: SortOrder
    beginningdate?: SortOrder
    enddatetime?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
  }

  export type TestTasksMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    groupid?: SortOrder
    description?: SortOrder
    img?: SortOrder
    beginningdate?: SortOrder
    enddatetime?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
  }

  export type TestTasksSumOrderByAggregateInput = {
    id?: SortOrder
    groupid?: SortOrder
    time?: SortOrder
    teacherid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AnswersListRelationFilter = {
    every?: AnswersWhereInput
    some?: AnswersWhereInput
    none?: AnswersWhereInput
  }

  export type TestTasksScalarRelationFilter = {
    is?: TestTasksWhereInput
    isNot?: TestTasksWhereInput
  }

  export type AnswersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    img?: SortOrder
    testtaskid?: SortOrder
  }

  export type QuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    testtaskid?: SortOrder
  }

  export type QuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    img?: SortOrder
    testtaskid?: SortOrder
  }

  export type QuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    img?: SortOrder
    testtaskid?: SortOrder
  }

  export type QuestionsSumOrderByAggregateInput = {
    id?: SortOrder
    testtaskid?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type QuestionsScalarRelationFilter = {
    is?: QuestionsWhereInput
    isNot?: QuestionsWhereInput
  }

  export type AnswersCountOrderByAggregateInput = {
    id?: SortOrder
    questionid?: SortOrder
    text?: SortOrder
    iscorrect?: SortOrder
  }

  export type AnswersAvgOrderByAggregateInput = {
    id?: SortOrder
    questionid?: SortOrder
  }

  export type AnswersMaxOrderByAggregateInput = {
    id?: SortOrder
    questionid?: SortOrder
    text?: SortOrder
    iscorrect?: SortOrder
  }

  export type AnswersMinOrderByAggregateInput = {
    id?: SortOrder
    questionid?: SortOrder
    text?: SortOrder
    iscorrect?: SortOrder
  }

  export type AnswersSumOrderByAggregateInput = {
    id?: SortOrder
    questionid?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StudentsScalarRelationFilter = {
    is?: StudentsWhereInput
    isNot?: StudentsWhereInput
  }

  export type GradesCountOrderByAggregateInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
    date?: SortOrder
  }

  export type GradesAvgOrderByAggregateInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
  }

  export type GradesMaxOrderByAggregateInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
    date?: SortOrder
  }

  export type GradesMinOrderByAggregateInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
    date?: SortOrder
  }

  export type GradesSumOrderByAggregateInput = {
    id?: SortOrder
    studentid?: SortOrder
    grade?: SortOrder
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUsersInput = {
    create?: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUsersInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput> | StudentsCreateWithoutUsersInput[] | StudentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutUsersInput | StudentsCreateOrConnectWithoutUsersInput[]
    createMany?: StudentsCreateManyUsersInputEnvelope
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUsersInput
    connect?: TeacherWhereUniqueInput
  }

  export type StudentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput> | StudentsCreateWithoutUsersInput[] | StudentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutUsersInput | StudentsCreateOrConnectWithoutUsersInput[]
    createMany?: StudentsCreateManyUsersInputEnvelope
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type TeacherUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUsersInput
    upsert?: TeacherUpsertWithoutUsersInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUsersInput, TeacherUpdateWithoutUsersInput>, TeacherUncheckedUpdateWithoutUsersInput>
  }

  export type StudentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput> | StudentsCreateWithoutUsersInput[] | StudentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutUsersInput | StudentsCreateOrConnectWithoutUsersInput[]
    upsert?: StudentsUpsertWithWhereUniqueWithoutUsersInput | StudentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StudentsCreateManyUsersInputEnvelope
    set?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    disconnect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    delete?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    update?: StudentsUpdateWithWhereUniqueWithoutUsersInput | StudentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StudentsUpdateManyWithWhereWithoutUsersInput | StudentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUsersInput
    upsert?: TeacherUpsertWithoutUsersInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUsersInput, TeacherUpdateWithoutUsersInput>, TeacherUncheckedUpdateWithoutUsersInput>
  }

  export type StudentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput> | StudentsCreateWithoutUsersInput[] | StudentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutUsersInput | StudentsCreateOrConnectWithoutUsersInput[]
    upsert?: StudentsUpsertWithWhereUniqueWithoutUsersInput | StudentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StudentsCreateManyUsersInputEnvelope
    set?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    disconnect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    delete?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    update?: StudentsUpdateWithWhereUniqueWithoutUsersInput | StudentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StudentsUpdateManyWithWhereWithoutUsersInput | StudentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeachersInput = {
    create?: XOR<UserCreateWithoutTeachersInput, UserUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeachersInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherGroupsCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput> | TeacherGroupsCreateWithoutTeacherInput[] | TeacherGroupsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutTeacherInput | TeacherGroupsCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherGroupsCreateManyTeacherInputEnvelope
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
  }

  export type TestTasksCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput> | TestTasksCreateWithoutTeacherInput[] | TestTasksUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutTeacherInput | TestTasksCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTasksCreateManyTeacherInputEnvelope
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
  }

  export type TeacherGroupsUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput> | TeacherGroupsCreateWithoutTeacherInput[] | TeacherGroupsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutTeacherInput | TeacherGroupsCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherGroupsCreateManyTeacherInputEnvelope
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
  }

  export type TestTasksUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput> | TestTasksCreateWithoutTeacherInput[] | TestTasksUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutTeacherInput | TestTasksCreateOrConnectWithoutTeacherInput[]
    createMany?: TestTasksCreateManyTeacherInputEnvelope
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<UserCreateWithoutTeachersInput, UserUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeachersInput
    upsert?: UserUpsertWithoutTeachersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeachersInput, UserUpdateWithoutTeachersInput>, UserUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherGroupsUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput> | TeacherGroupsCreateWithoutTeacherInput[] | TeacherGroupsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutTeacherInput | TeacherGroupsCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherGroupsUpsertWithWhereUniqueWithoutTeacherInput | TeacherGroupsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherGroupsCreateManyTeacherInputEnvelope
    set?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    disconnect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    delete?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    update?: TeacherGroupsUpdateWithWhereUniqueWithoutTeacherInput | TeacherGroupsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherGroupsUpdateManyWithWhereWithoutTeacherInput | TeacherGroupsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
  }

  export type TestTasksUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput> | TestTasksCreateWithoutTeacherInput[] | TestTasksUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutTeacherInput | TestTasksCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTasksUpsertWithWhereUniqueWithoutTeacherInput | TestTasksUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTasksCreateManyTeacherInputEnvelope
    set?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    disconnect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    delete?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    update?: TestTasksUpdateWithWhereUniqueWithoutTeacherInput | TestTasksUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTasksUpdateManyWithWhereWithoutTeacherInput | TestTasksUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
  }

  export type TeacherGroupsUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput> | TeacherGroupsCreateWithoutTeacherInput[] | TeacherGroupsUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutTeacherInput | TeacherGroupsCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherGroupsUpsertWithWhereUniqueWithoutTeacherInput | TeacherGroupsUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherGroupsCreateManyTeacherInputEnvelope
    set?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    disconnect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    delete?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    update?: TeacherGroupsUpdateWithWhereUniqueWithoutTeacherInput | TeacherGroupsUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherGroupsUpdateManyWithWhereWithoutTeacherInput | TeacherGroupsUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
  }

  export type TestTasksUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput> | TestTasksCreateWithoutTeacherInput[] | TestTasksUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutTeacherInput | TestTasksCreateOrConnectWithoutTeacherInput[]
    upsert?: TestTasksUpsertWithWhereUniqueWithoutTeacherInput | TestTasksUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TestTasksCreateManyTeacherInputEnvelope
    set?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    disconnect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    delete?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    update?: TestTasksUpdateWithWhereUniqueWithoutTeacherInput | TestTasksUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TestTasksUpdateManyWithWhereWithoutTeacherInput | TestTasksUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
  }

  export type StudentsCreateNestedManyWithoutGroupInput = {
    create?: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput> | StudentsCreateWithoutGroupInput[] | StudentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutGroupInput | StudentsCreateOrConnectWithoutGroupInput[]
    createMany?: StudentsCreateManyGroupInputEnvelope
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
  }

  export type TeacherGroupsCreateNestedManyWithoutGroupInput = {
    create?: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput> | TeacherGroupsCreateWithoutGroupInput[] | TeacherGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutGroupInput | TeacherGroupsCreateOrConnectWithoutGroupInput[]
    createMany?: TeacherGroupsCreateManyGroupInputEnvelope
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
  }

  export type TestTasksCreateNestedManyWithoutGroupsInput = {
    create?: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput> | TestTasksCreateWithoutGroupsInput[] | TestTasksUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutGroupsInput | TestTasksCreateOrConnectWithoutGroupsInput[]
    createMany?: TestTasksCreateManyGroupsInputEnvelope
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
  }

  export type StudentsUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput> | StudentsCreateWithoutGroupInput[] | StudentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutGroupInput | StudentsCreateOrConnectWithoutGroupInput[]
    createMany?: StudentsCreateManyGroupInputEnvelope
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
  }

  export type TeacherGroupsUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput> | TeacherGroupsCreateWithoutGroupInput[] | TeacherGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutGroupInput | TeacherGroupsCreateOrConnectWithoutGroupInput[]
    createMany?: TeacherGroupsCreateManyGroupInputEnvelope
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
  }

  export type TestTasksUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput> | TestTasksCreateWithoutGroupsInput[] | TestTasksUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutGroupsInput | TestTasksCreateOrConnectWithoutGroupsInput[]
    createMany?: TestTasksCreateManyGroupsInputEnvelope
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
  }

  export type StudentsUpdateManyWithoutGroupNestedInput = {
    create?: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput> | StudentsCreateWithoutGroupInput[] | StudentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutGroupInput | StudentsCreateOrConnectWithoutGroupInput[]
    upsert?: StudentsUpsertWithWhereUniqueWithoutGroupInput | StudentsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: StudentsCreateManyGroupInputEnvelope
    set?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    disconnect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    delete?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    update?: StudentsUpdateWithWhereUniqueWithoutGroupInput | StudentsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: StudentsUpdateManyWithWhereWithoutGroupInput | StudentsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
  }

  export type TeacherGroupsUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput> | TeacherGroupsCreateWithoutGroupInput[] | TeacherGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutGroupInput | TeacherGroupsCreateOrConnectWithoutGroupInput[]
    upsert?: TeacherGroupsUpsertWithWhereUniqueWithoutGroupInput | TeacherGroupsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TeacherGroupsCreateManyGroupInputEnvelope
    set?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    disconnect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    delete?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    update?: TeacherGroupsUpdateWithWhereUniqueWithoutGroupInput | TeacherGroupsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TeacherGroupsUpdateManyWithWhereWithoutGroupInput | TeacherGroupsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
  }

  export type TestTasksUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput> | TestTasksCreateWithoutGroupsInput[] | TestTasksUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutGroupsInput | TestTasksCreateOrConnectWithoutGroupsInput[]
    upsert?: TestTasksUpsertWithWhereUniqueWithoutGroupsInput | TestTasksUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: TestTasksCreateManyGroupsInputEnvelope
    set?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    disconnect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    delete?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    update?: TestTasksUpdateWithWhereUniqueWithoutGroupsInput | TestTasksUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: TestTasksUpdateManyWithWhereWithoutGroupsInput | TestTasksUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
  }

  export type StudentsUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput> | StudentsCreateWithoutGroupInput[] | StudentsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudentsCreateOrConnectWithoutGroupInput | StudentsCreateOrConnectWithoutGroupInput[]
    upsert?: StudentsUpsertWithWhereUniqueWithoutGroupInput | StudentsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: StudentsCreateManyGroupInputEnvelope
    set?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    disconnect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    delete?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    connect?: StudentsWhereUniqueInput | StudentsWhereUniqueInput[]
    update?: StudentsUpdateWithWhereUniqueWithoutGroupInput | StudentsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: StudentsUpdateManyWithWhereWithoutGroupInput | StudentsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
  }

  export type TeacherGroupsUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput> | TeacherGroupsCreateWithoutGroupInput[] | TeacherGroupsUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TeacherGroupsCreateOrConnectWithoutGroupInput | TeacherGroupsCreateOrConnectWithoutGroupInput[]
    upsert?: TeacherGroupsUpsertWithWhereUniqueWithoutGroupInput | TeacherGroupsUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TeacherGroupsCreateManyGroupInputEnvelope
    set?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    disconnect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    delete?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    connect?: TeacherGroupsWhereUniqueInput | TeacherGroupsWhereUniqueInput[]
    update?: TeacherGroupsUpdateWithWhereUniqueWithoutGroupInput | TeacherGroupsUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TeacherGroupsUpdateManyWithWhereWithoutGroupInput | TeacherGroupsUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
  }

  export type TestTasksUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput> | TestTasksCreateWithoutGroupsInput[] | TestTasksUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: TestTasksCreateOrConnectWithoutGroupsInput | TestTasksCreateOrConnectWithoutGroupsInput[]
    upsert?: TestTasksUpsertWithWhereUniqueWithoutGroupsInput | TestTasksUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: TestTasksCreateManyGroupsInputEnvelope
    set?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    disconnect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    delete?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    connect?: TestTasksWhereUniqueInput | TestTasksWhereUniqueInput[]
    update?: TestTasksUpdateWithWhereUniqueWithoutGroupsInput | TestTasksUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: TestTasksUpdateManyWithWhereWithoutGroupsInput | TestTasksUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupsCreateNestedOneWithoutStudentsInput = {
    create?: XOR<GroupsCreateWithoutStudentsInput, GroupsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutStudentsInput
    connect?: GroupsWhereUniqueInput
  }

  export type GradesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput> | GradesCreateWithoutStudentsInput[] | GradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: GradesCreateOrConnectWithoutStudentsInput | GradesCreateOrConnectWithoutStudentsInput[]
    createMany?: GradesCreateManyStudentsInputEnvelope
    connect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
  }

  export type GradesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput> | GradesCreateWithoutStudentsInput[] | GradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: GradesCreateOrConnectWithoutStudentsInput | GradesCreateOrConnectWithoutStudentsInput[]
    createMany?: GradesCreateManyStudentsInputEnvelope
    connect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    upsert?: UserUpsertWithoutStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentsInput, UserUpdateWithoutStudentsInput>, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type GroupsUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<GroupsCreateWithoutStudentsInput, GroupsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutStudentsInput
    upsert?: GroupsUpsertWithoutStudentsInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutStudentsInput, GroupsUpdateWithoutStudentsInput>, GroupsUncheckedUpdateWithoutStudentsInput>
  }

  export type GradesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput> | GradesCreateWithoutStudentsInput[] | GradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: GradesCreateOrConnectWithoutStudentsInput | GradesCreateOrConnectWithoutStudentsInput[]
    upsert?: GradesUpsertWithWhereUniqueWithoutStudentsInput | GradesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: GradesCreateManyStudentsInputEnvelope
    set?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    disconnect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    delete?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    connect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    update?: GradesUpdateWithWhereUniqueWithoutStudentsInput | GradesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: GradesUpdateManyWithWhereWithoutStudentsInput | GradesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: GradesScalarWhereInput | GradesScalarWhereInput[]
  }

  export type GradesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput> | GradesCreateWithoutStudentsInput[] | GradesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: GradesCreateOrConnectWithoutStudentsInput | GradesCreateOrConnectWithoutStudentsInput[]
    upsert?: GradesUpsertWithWhereUniqueWithoutStudentsInput | GradesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: GradesCreateManyStudentsInputEnvelope
    set?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    disconnect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    delete?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    connect?: GradesWhereUniqueInput | GradesWhereUniqueInput[]
    update?: GradesUpdateWithWhereUniqueWithoutStudentsInput | GradesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: GradesUpdateManyWithWhereWithoutStudentsInput | GradesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: GradesScalarWhereInput | GradesScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutTeacherGroupsInput = {
    create?: XOR<TeacherCreateWithoutTeacherGroupsInput, TeacherUncheckedCreateWithoutTeacherGroupsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacherGroupsInput
    connect?: TeacherWhereUniqueInput
  }

  export type GroupsCreateNestedOneWithoutTeacherGroupsInput = {
    create?: XOR<GroupsCreateWithoutTeacherGroupsInput, GroupsUncheckedCreateWithoutTeacherGroupsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutTeacherGroupsInput
    connect?: GroupsWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutTeacherGroupsNestedInput = {
    create?: XOR<TeacherCreateWithoutTeacherGroupsInput, TeacherUncheckedCreateWithoutTeacherGroupsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTeacherGroupsInput
    upsert?: TeacherUpsertWithoutTeacherGroupsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTeacherGroupsInput, TeacherUpdateWithoutTeacherGroupsInput>, TeacherUncheckedUpdateWithoutTeacherGroupsInput>
  }

  export type GroupsUpdateOneRequiredWithoutTeacherGroupsNestedInput = {
    create?: XOR<GroupsCreateWithoutTeacherGroupsInput, GroupsUncheckedCreateWithoutTeacherGroupsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutTeacherGroupsInput
    upsert?: GroupsUpsertWithoutTeacherGroupsInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutTeacherGroupsInput, GroupsUpdateWithoutTeacherGroupsInput>, GroupsUncheckedUpdateWithoutTeacherGroupsInput>
  }

  export type GroupsCreateNestedOneWithoutTestTasksInput = {
    create?: XOR<GroupsCreateWithoutTestTasksInput, GroupsUncheckedCreateWithoutTestTasksInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutTestTasksInput
    connect?: GroupsWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutTestTasksInput = {
    create?: XOR<TeacherCreateWithoutTestTasksInput, TeacherUncheckedCreateWithoutTestTasksInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTestTasksInput
    connect?: TeacherWhereUniqueInput
  }

  export type QuestionsCreateNestedManyWithoutTesttasksInput = {
    create?: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput> | QuestionsCreateWithoutTesttasksInput[] | QuestionsUncheckedCreateWithoutTesttasksInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutTesttasksInput | QuestionsCreateOrConnectWithoutTesttasksInput[]
    createMany?: QuestionsCreateManyTesttasksInputEnvelope
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
  }

  export type QuestionsUncheckedCreateNestedManyWithoutTesttasksInput = {
    create?: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput> | QuestionsCreateWithoutTesttasksInput[] | QuestionsUncheckedCreateWithoutTesttasksInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutTesttasksInput | QuestionsCreateOrConnectWithoutTesttasksInput[]
    createMany?: QuestionsCreateManyTesttasksInputEnvelope
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type GroupsUpdateOneRequiredWithoutTestTasksNestedInput = {
    create?: XOR<GroupsCreateWithoutTestTasksInput, GroupsUncheckedCreateWithoutTestTasksInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutTestTasksInput
    upsert?: GroupsUpsertWithoutTestTasksInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutTestTasksInput, GroupsUpdateWithoutTestTasksInput>, GroupsUncheckedUpdateWithoutTestTasksInput>
  }

  export type TeacherUpdateOneRequiredWithoutTestTasksNestedInput = {
    create?: XOR<TeacherCreateWithoutTestTasksInput, TeacherUncheckedCreateWithoutTestTasksInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTestTasksInput
    upsert?: TeacherUpsertWithoutTestTasksInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTestTasksInput, TeacherUpdateWithoutTestTasksInput>, TeacherUncheckedUpdateWithoutTestTasksInput>
  }

  export type QuestionsUpdateManyWithoutTesttasksNestedInput = {
    create?: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput> | QuestionsCreateWithoutTesttasksInput[] | QuestionsUncheckedCreateWithoutTesttasksInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutTesttasksInput | QuestionsCreateOrConnectWithoutTesttasksInput[]
    upsert?: QuestionsUpsertWithWhereUniqueWithoutTesttasksInput | QuestionsUpsertWithWhereUniqueWithoutTesttasksInput[]
    createMany?: QuestionsCreateManyTesttasksInputEnvelope
    set?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    disconnect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    delete?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    update?: QuestionsUpdateWithWhereUniqueWithoutTesttasksInput | QuestionsUpdateWithWhereUniqueWithoutTesttasksInput[]
    updateMany?: QuestionsUpdateManyWithWhereWithoutTesttasksInput | QuestionsUpdateManyWithWhereWithoutTesttasksInput[]
    deleteMany?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
  }

  export type QuestionsUncheckedUpdateManyWithoutTesttasksNestedInput = {
    create?: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput> | QuestionsCreateWithoutTesttasksInput[] | QuestionsUncheckedCreateWithoutTesttasksInput[]
    connectOrCreate?: QuestionsCreateOrConnectWithoutTesttasksInput | QuestionsCreateOrConnectWithoutTesttasksInput[]
    upsert?: QuestionsUpsertWithWhereUniqueWithoutTesttasksInput | QuestionsUpsertWithWhereUniqueWithoutTesttasksInput[]
    createMany?: QuestionsCreateManyTesttasksInputEnvelope
    set?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    disconnect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    delete?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    connect?: QuestionsWhereUniqueInput | QuestionsWhereUniqueInput[]
    update?: QuestionsUpdateWithWhereUniqueWithoutTesttasksInput | QuestionsUpdateWithWhereUniqueWithoutTesttasksInput[]
    updateMany?: QuestionsUpdateManyWithWhereWithoutTesttasksInput | QuestionsUpdateManyWithWhereWithoutTesttasksInput[]
    deleteMany?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
  }

  export type AnswersCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput> | AnswersCreateWithoutQuestionInput[] | AnswersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionInput | AnswersCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswersCreateManyQuestionInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type TestTasksCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<TestTasksCreateWithoutQuestionsInput, TestTasksUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTasksCreateOrConnectWithoutQuestionsInput
    connect?: TestTasksWhereUniqueInput
  }

  export type AnswersUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput> | AnswersCreateWithoutQuestionInput[] | AnswersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionInput | AnswersCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswersCreateManyQuestionInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type AnswersUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput> | AnswersCreateWithoutQuestionInput[] | AnswersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionInput | AnswersCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutQuestionInput | AnswersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswersCreateManyQuestionInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutQuestionInput | AnswersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutQuestionInput | AnswersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type TestTasksUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<TestTasksCreateWithoutQuestionsInput, TestTasksUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: TestTasksCreateOrConnectWithoutQuestionsInput
    upsert?: TestTasksUpsertWithoutQuestionsInput
    connect?: TestTasksWhereUniqueInput
    update?: XOR<XOR<TestTasksUpdateToOneWithWhereWithoutQuestionsInput, TestTasksUpdateWithoutQuestionsInput>, TestTasksUncheckedUpdateWithoutQuestionsInput>
  }

  export type AnswersUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput> | AnswersCreateWithoutQuestionInput[] | AnswersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutQuestionInput | AnswersCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutQuestionInput | AnswersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswersCreateManyQuestionInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutQuestionInput | AnswersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutQuestionInput | AnswersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type QuestionsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutAnswersInput
    connect?: QuestionsWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type QuestionsUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutAnswersInput
    upsert?: QuestionsUpsertWithoutAnswersInput
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutAnswersInput, QuestionsUpdateWithoutAnswersInput>, QuestionsUncheckedUpdateWithoutAnswersInput>
  }

  export type StudentsCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentsCreateWithoutGradesInput, StudentsUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutGradesInput
    connect?: StudentsWhereUniqueInput
  }

  export type StudentsUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentsCreateWithoutGradesInput, StudentsUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutGradesInput
    upsert?: StudentsUpsertWithoutGradesInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutGradesInput, StudentsUpdateWithoutGradesInput>, StudentsUncheckedUpdateWithoutGradesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutRoleInput = {
    passwordhash: string
    login: string
    date?: Date | string
    teachers?: TeacherCreateNestedOneWithoutUsersInput
    students?: StudentsCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
    teachers?: TeacherUncheckedCreateNestedOneWithoutUsersInput
    students?: StudentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    passwordhash?: StringFilter<"User"> | string
    login?: StringFilter<"User"> | string
    date?: DateTimeFilter<"User"> | Date | string
    roleid?: IntFilter<"User"> | number
  }

  export type RoleCreateWithoutUsersInput = {
    title: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type TeacherCreateWithoutUsersInput = {
    name: string
    lastname: string
    patronymic: string
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutTeacherInput
    testTasks?: TestTasksCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutTeacherInput
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUsersInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
  }

  export type StudentsCreateWithoutUsersInput = {
    name: string
    lastname: string
    patronymic: string
    group: GroupsCreateNestedOneWithoutStudentsInput
    grades?: GradesCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    groupId: number
    grades?: GradesUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsCreateOrConnectWithoutUsersInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput>
  }

  export type StudentsCreateManyUsersInputEnvelope = {
    data: StudentsCreateManyUsersInput | StudentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherUpsertWithoutUsersInput = {
    update: XOR<TeacherUpdateWithoutUsersInput, TeacherUncheckedUpdateWithoutUsersInput>
    create: XOR<TeacherCreateWithoutUsersInput, TeacherUncheckedCreateWithoutUsersInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUsersInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUsersInput, TeacherUncheckedUpdateWithoutUsersInput>
  }

  export type TeacherUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    teacherGroups?: TeacherGroupsUpdateManyWithoutTeacherNestedInput
    testTasks?: TestTasksUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutTeacherNestedInput
    testTasks?: TestTasksUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: StudentsWhereUniqueInput
    update: XOR<StudentsUpdateWithoutUsersInput, StudentsUncheckedUpdateWithoutUsersInput>
    create: XOR<StudentsCreateWithoutUsersInput, StudentsUncheckedCreateWithoutUsersInput>
  }

  export type StudentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: StudentsWhereUniqueInput
    data: XOR<StudentsUpdateWithoutUsersInput, StudentsUncheckedUpdateWithoutUsersInput>
  }

  export type StudentsUpdateManyWithWhereWithoutUsersInput = {
    where: StudentsScalarWhereInput
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type StudentsScalarWhereInput = {
    AND?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
    OR?: StudentsScalarWhereInput[]
    NOT?: StudentsScalarWhereInput | StudentsScalarWhereInput[]
    id?: IntFilter<"Students"> | number
    name?: StringFilter<"Students"> | string
    lastname?: StringFilter<"Students"> | string
    patronymic?: StringFilter<"Students"> | string
    userId?: IntFilter<"Students"> | number
    groupId?: IntFilter<"Students"> | number
  }

  export type UserCreateWithoutTeachersInput = {
    passwordhash: string
    login: string
    date?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    students?: StudentsCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTeachersInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
    roleid: number
    students?: StudentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTeachersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeachersInput, UserUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherGroupsCreateWithoutTeacherInput = {
    group: GroupsCreateNestedOneWithoutTeacherGroupsInput
  }

  export type TeacherGroupsUncheckedCreateWithoutTeacherInput = {
    id?: number
    groupId: number
  }

  export type TeacherGroupsCreateOrConnectWithoutTeacherInput = {
    where: TeacherGroupsWhereUniqueInput
    create: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherGroupsCreateManyTeacherInputEnvelope = {
    data: TeacherGroupsCreateManyTeacherInput | TeacherGroupsCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TestTasksCreateWithoutTeacherInput = {
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    groups: GroupsCreateNestedOneWithoutTestTasksInput
    questions?: QuestionsCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksUncheckedCreateWithoutTeacherInput = {
    id?: number
    title: string
    groupid: number
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    questions?: QuestionsUncheckedCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksCreateOrConnectWithoutTeacherInput = {
    where: TestTasksWhereUniqueInput
    create: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput>
  }

  export type TestTasksCreateManyTeacherInputEnvelope = {
    data: TestTasksCreateManyTeacherInput | TestTasksCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeachersInput = {
    update: XOR<UserUpdateWithoutTeachersInput, UserUncheckedUpdateWithoutTeachersInput>
    create: XOR<UserCreateWithoutTeachersInput, UserUncheckedCreateWithoutTeachersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeachersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeachersInput, UserUncheckedUpdateWithoutTeachersInput>
  }

  export type UserUpdateWithoutTeachersInput = {
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    students?: StudentsUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roleid?: IntFieldUpdateOperationsInput | number
    students?: StudentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TeacherGroupsUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherGroupsWhereUniqueInput
    update: XOR<TeacherGroupsUpdateWithoutTeacherInput, TeacherGroupsUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherGroupsCreateWithoutTeacherInput, TeacherGroupsUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherGroupsUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherGroupsWhereUniqueInput
    data: XOR<TeacherGroupsUpdateWithoutTeacherInput, TeacherGroupsUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherGroupsUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherGroupsScalarWhereInput
    data: XOR<TeacherGroupsUpdateManyMutationInput, TeacherGroupsUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherGroupsScalarWhereInput = {
    AND?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
    OR?: TeacherGroupsScalarWhereInput[]
    NOT?: TeacherGroupsScalarWhereInput | TeacherGroupsScalarWhereInput[]
    id?: IntFilter<"TeacherGroups"> | number
    teacherId?: IntFilter<"TeacherGroups"> | number
    groupId?: IntFilter<"TeacherGroups"> | number
  }

  export type TestTasksUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TestTasksWhereUniqueInput
    update: XOR<TestTasksUpdateWithoutTeacherInput, TestTasksUncheckedUpdateWithoutTeacherInput>
    create: XOR<TestTasksCreateWithoutTeacherInput, TestTasksUncheckedCreateWithoutTeacherInput>
  }

  export type TestTasksUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TestTasksWhereUniqueInput
    data: XOR<TestTasksUpdateWithoutTeacherInput, TestTasksUncheckedUpdateWithoutTeacherInput>
  }

  export type TestTasksUpdateManyWithWhereWithoutTeacherInput = {
    where: TestTasksScalarWhereInput
    data: XOR<TestTasksUpdateManyMutationInput, TestTasksUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TestTasksScalarWhereInput = {
    AND?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
    OR?: TestTasksScalarWhereInput[]
    NOT?: TestTasksScalarWhereInput | TestTasksScalarWhereInput[]
    id?: IntFilter<"TestTasks"> | number
    title?: StringFilter<"TestTasks"> | string
    groupid?: IntFilter<"TestTasks"> | number
    description?: StringFilter<"TestTasks"> | string
    img?: StringNullableFilter<"TestTasks"> | string | null
    beginningdate?: DateTimeFilter<"TestTasks"> | Date | string
    enddatetime?: DateTimeFilter<"TestTasks"> | Date | string
    time?: IntFilter<"TestTasks"> | number
    teacherid?: IntFilter<"TestTasks"> | number
  }

  export type StudentsCreateWithoutGroupInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutStudentsInput
    grades?: GradesCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateWithoutGroupInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userId: number
    grades?: GradesUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsCreateOrConnectWithoutGroupInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput>
  }

  export type StudentsCreateManyGroupInputEnvelope = {
    data: StudentsCreateManyGroupInput | StudentsCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TeacherGroupsCreateWithoutGroupInput = {
    teacher: TeacherCreateNestedOneWithoutTeacherGroupsInput
  }

  export type TeacherGroupsUncheckedCreateWithoutGroupInput = {
    id?: number
    teacherId: number
  }

  export type TeacherGroupsCreateOrConnectWithoutGroupInput = {
    where: TeacherGroupsWhereUniqueInput
    create: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput>
  }

  export type TeacherGroupsCreateManyGroupInputEnvelope = {
    data: TeacherGroupsCreateManyGroupInput | TeacherGroupsCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type TestTasksCreateWithoutGroupsInput = {
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacher: TeacherCreateNestedOneWithoutTestTasksInput
    questions?: QuestionsCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksUncheckedCreateWithoutGroupsInput = {
    id?: number
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacherid: number
    questions?: QuestionsUncheckedCreateNestedManyWithoutTesttasksInput
  }

  export type TestTasksCreateOrConnectWithoutGroupsInput = {
    where: TestTasksWhereUniqueInput
    create: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput>
  }

  export type TestTasksCreateManyGroupsInputEnvelope = {
    data: TestTasksCreateManyGroupsInput | TestTasksCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type StudentsUpsertWithWhereUniqueWithoutGroupInput = {
    where: StudentsWhereUniqueInput
    update: XOR<StudentsUpdateWithoutGroupInput, StudentsUncheckedUpdateWithoutGroupInput>
    create: XOR<StudentsCreateWithoutGroupInput, StudentsUncheckedCreateWithoutGroupInput>
  }

  export type StudentsUpdateWithWhereUniqueWithoutGroupInput = {
    where: StudentsWhereUniqueInput
    data: XOR<StudentsUpdateWithoutGroupInput, StudentsUncheckedUpdateWithoutGroupInput>
  }

  export type StudentsUpdateManyWithWhereWithoutGroupInput = {
    where: StudentsScalarWhereInput
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyWithoutGroupInput>
  }

  export type TeacherGroupsUpsertWithWhereUniqueWithoutGroupInput = {
    where: TeacherGroupsWhereUniqueInput
    update: XOR<TeacherGroupsUpdateWithoutGroupInput, TeacherGroupsUncheckedUpdateWithoutGroupInput>
    create: XOR<TeacherGroupsCreateWithoutGroupInput, TeacherGroupsUncheckedCreateWithoutGroupInput>
  }

  export type TeacherGroupsUpdateWithWhereUniqueWithoutGroupInput = {
    where: TeacherGroupsWhereUniqueInput
    data: XOR<TeacherGroupsUpdateWithoutGroupInput, TeacherGroupsUncheckedUpdateWithoutGroupInput>
  }

  export type TeacherGroupsUpdateManyWithWhereWithoutGroupInput = {
    where: TeacherGroupsScalarWhereInput
    data: XOR<TeacherGroupsUpdateManyMutationInput, TeacherGroupsUncheckedUpdateManyWithoutGroupInput>
  }

  export type TestTasksUpsertWithWhereUniqueWithoutGroupsInput = {
    where: TestTasksWhereUniqueInput
    update: XOR<TestTasksUpdateWithoutGroupsInput, TestTasksUncheckedUpdateWithoutGroupsInput>
    create: XOR<TestTasksCreateWithoutGroupsInput, TestTasksUncheckedCreateWithoutGroupsInput>
  }

  export type TestTasksUpdateWithWhereUniqueWithoutGroupsInput = {
    where: TestTasksWhereUniqueInput
    data: XOR<TestTasksUpdateWithoutGroupsInput, TestTasksUncheckedUpdateWithoutGroupsInput>
  }

  export type TestTasksUpdateManyWithWhereWithoutGroupsInput = {
    where: TestTasksScalarWhereInput
    data: XOR<TestTasksUpdateManyMutationInput, TestTasksUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserCreateWithoutStudentsInput = {
    passwordhash: string
    login: string
    date?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    teachers?: TeacherCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutStudentsInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
    roleid: number
    teachers?: TeacherUncheckedCreateNestedOneWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
  }

  export type GroupsCreateWithoutStudentsInput = {
    title: string
    course: number
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutStudentsInput = {
    id?: number
    title: string
    course: number
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutStudentsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutStudentsInput, GroupsUncheckedCreateWithoutStudentsInput>
  }

  export type GradesCreateWithoutStudentsInput = {
    grade: number
    date: Date | string
  }

  export type GradesUncheckedCreateWithoutStudentsInput = {
    id?: number
    grade: number
    date: Date | string
  }

  export type GradesCreateOrConnectWithoutStudentsInput = {
    where: GradesWhereUniqueInput
    create: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput>
  }

  export type GradesCreateManyStudentsInputEnvelope = {
    data: GradesCreateManyStudentsInput | GradesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentsInput = {
    update: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateWithoutStudentsInput = {
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    teachers?: TeacherUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    roleid?: IntFieldUpdateOperationsInput | number
    teachers?: TeacherUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type GroupsUpsertWithoutStudentsInput = {
    update: XOR<GroupsUpdateWithoutStudentsInput, GroupsUncheckedUpdateWithoutStudentsInput>
    create: XOR<GroupsCreateWithoutStudentsInput, GroupsUncheckedCreateWithoutStudentsInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutStudentsInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutStudentsInput, GroupsUncheckedUpdateWithoutStudentsInput>
  }

  export type GroupsUpdateWithoutStudentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    teacherGroups?: TeacherGroupsUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GradesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: GradesWhereUniqueInput
    update: XOR<GradesUpdateWithoutStudentsInput, GradesUncheckedUpdateWithoutStudentsInput>
    create: XOR<GradesCreateWithoutStudentsInput, GradesUncheckedCreateWithoutStudentsInput>
  }

  export type GradesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: GradesWhereUniqueInput
    data: XOR<GradesUpdateWithoutStudentsInput, GradesUncheckedUpdateWithoutStudentsInput>
  }

  export type GradesUpdateManyWithWhereWithoutStudentsInput = {
    where: GradesScalarWhereInput
    data: XOR<GradesUpdateManyMutationInput, GradesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type GradesScalarWhereInput = {
    AND?: GradesScalarWhereInput | GradesScalarWhereInput[]
    OR?: GradesScalarWhereInput[]
    NOT?: GradesScalarWhereInput | GradesScalarWhereInput[]
    id?: IntFilter<"Grades"> | number
    studentid?: IntFilter<"Grades"> | number
    grade?: IntFilter<"Grades"> | number
    date?: DateTimeFilter<"Grades"> | Date | string
  }

  export type TeacherCreateWithoutTeacherGroupsInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutTeachersInput
    testTasks?: TestTasksCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTeacherGroupsInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userid: number
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTeacherGroupsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTeacherGroupsInput, TeacherUncheckedCreateWithoutTeacherGroupsInput>
  }

  export type GroupsCreateWithoutTeacherGroupsInput = {
    title: string
    course: number
    students?: StudentsCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutTeacherGroupsInput = {
    id?: number
    title: string
    course: number
    students?: StudentsUncheckedCreateNestedManyWithoutGroupInput
    testTasks?: TestTasksUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutTeacherGroupsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutTeacherGroupsInput, GroupsUncheckedCreateWithoutTeacherGroupsInput>
  }

  export type TeacherUpsertWithoutTeacherGroupsInput = {
    update: XOR<TeacherUpdateWithoutTeacherGroupsInput, TeacherUncheckedUpdateWithoutTeacherGroupsInput>
    create: XOR<TeacherCreateWithoutTeacherGroupsInput, TeacherUncheckedCreateWithoutTeacherGroupsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTeacherGroupsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTeacherGroupsInput, TeacherUncheckedUpdateWithoutTeacherGroupsInput>
  }

  export type TeacherUpdateWithoutTeacherGroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutTeachersNestedInput
    testTasks?: TestTasksUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTeacherGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    testTasks?: TestTasksUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type GroupsUpsertWithoutTeacherGroupsInput = {
    update: XOR<GroupsUpdateWithoutTeacherGroupsInput, GroupsUncheckedUpdateWithoutTeacherGroupsInput>
    create: XOR<GroupsCreateWithoutTeacherGroupsInput, GroupsUncheckedCreateWithoutTeacherGroupsInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutTeacherGroupsInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutTeacherGroupsInput, GroupsUncheckedUpdateWithoutTeacherGroupsInput>
  }

  export type GroupsUpdateWithoutTeacherGroupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutTeacherGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUncheckedUpdateManyWithoutGroupNestedInput
    testTasks?: TestTasksUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsCreateWithoutTestTasksInput = {
    title: string
    course: number
    students?: StudentsCreateNestedManyWithoutGroupInput
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutGroupInput
  }

  export type GroupsUncheckedCreateWithoutTestTasksInput = {
    id?: number
    title: string
    course: number
    students?: StudentsUncheckedCreateNestedManyWithoutGroupInput
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupsCreateOrConnectWithoutTestTasksInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutTestTasksInput, GroupsUncheckedCreateWithoutTestTasksInput>
  }

  export type TeacherCreateWithoutTestTasksInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutTeachersInput
    teacherGroups?: TeacherGroupsCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTestTasksInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userid: number
    teacherGroups?: TeacherGroupsUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTestTasksInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTestTasksInput, TeacherUncheckedCreateWithoutTestTasksInput>
  }

  export type QuestionsCreateWithoutTesttasksInput = {
    description: string
    img?: string | null
    answers?: AnswersCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsUncheckedCreateWithoutTesttasksInput = {
    id?: number
    description: string
    img?: string | null
    answers?: AnswersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionsCreateOrConnectWithoutTesttasksInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput>
  }

  export type QuestionsCreateManyTesttasksInputEnvelope = {
    data: QuestionsCreateManyTesttasksInput | QuestionsCreateManyTesttasksInput[]
    skipDuplicates?: boolean
  }

  export type GroupsUpsertWithoutTestTasksInput = {
    update: XOR<GroupsUpdateWithoutTestTasksInput, GroupsUncheckedUpdateWithoutTestTasksInput>
    create: XOR<GroupsCreateWithoutTestTasksInput, GroupsUncheckedCreateWithoutTestTasksInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutTestTasksInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutTestTasksInput, GroupsUncheckedUpdateWithoutTestTasksInput>
  }

  export type GroupsUpdateWithoutTestTasksInput = {
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUpdateManyWithoutGroupNestedInput
    teacherGroups?: TeacherGroupsUpdateManyWithoutGroupNestedInput
  }

  export type GroupsUncheckedUpdateWithoutTestTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    course?: IntFieldUpdateOperationsInput | number
    students?: StudentsUncheckedUpdateManyWithoutGroupNestedInput
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type TeacherUpsertWithoutTestTasksInput = {
    update: XOR<TeacherUpdateWithoutTestTasksInput, TeacherUncheckedUpdateWithoutTestTasksInput>
    create: XOR<TeacherCreateWithoutTestTasksInput, TeacherUncheckedCreateWithoutTestTasksInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTestTasksInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTestTasksInput, TeacherUncheckedUpdateWithoutTestTasksInput>
  }

  export type TeacherUpdateWithoutTestTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutTeachersNestedInput
    teacherGroups?: TeacherGroupsUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTestTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userid?: IntFieldUpdateOperationsInput | number
    teacherGroups?: TeacherGroupsUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type QuestionsUpsertWithWhereUniqueWithoutTesttasksInput = {
    where: QuestionsWhereUniqueInput
    update: XOR<QuestionsUpdateWithoutTesttasksInput, QuestionsUncheckedUpdateWithoutTesttasksInput>
    create: XOR<QuestionsCreateWithoutTesttasksInput, QuestionsUncheckedCreateWithoutTesttasksInput>
  }

  export type QuestionsUpdateWithWhereUniqueWithoutTesttasksInput = {
    where: QuestionsWhereUniqueInput
    data: XOR<QuestionsUpdateWithoutTesttasksInput, QuestionsUncheckedUpdateWithoutTesttasksInput>
  }

  export type QuestionsUpdateManyWithWhereWithoutTesttasksInput = {
    where: QuestionsScalarWhereInput
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyWithoutTesttasksInput>
  }

  export type QuestionsScalarWhereInput = {
    AND?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
    OR?: QuestionsScalarWhereInput[]
    NOT?: QuestionsScalarWhereInput | QuestionsScalarWhereInput[]
    id?: IntFilter<"Questions"> | number
    description?: StringFilter<"Questions"> | string
    img?: StringNullableFilter<"Questions"> | string | null
    testtaskid?: IntFilter<"Questions"> | number
  }

  export type AnswersCreateWithoutQuestionInput = {
    text: string
    iscorrect?: boolean | null
  }

  export type AnswersUncheckedCreateWithoutQuestionInput = {
    id?: number
    text: string
    iscorrect?: boolean | null
  }

  export type AnswersCreateOrConnectWithoutQuestionInput = {
    where: AnswersWhereUniqueInput
    create: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput>
  }

  export type AnswersCreateManyQuestionInputEnvelope = {
    data: AnswersCreateManyQuestionInput | AnswersCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type TestTasksCreateWithoutQuestionsInput = {
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    groups: GroupsCreateNestedOneWithoutTestTasksInput
    teacher: TeacherCreateNestedOneWithoutTestTasksInput
  }

  export type TestTasksUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    groupid: number
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacherid: number
  }

  export type TestTasksCreateOrConnectWithoutQuestionsInput = {
    where: TestTasksWhereUniqueInput
    create: XOR<TestTasksCreateWithoutQuestionsInput, TestTasksUncheckedCreateWithoutQuestionsInput>
  }

  export type AnswersUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswersWhereUniqueInput
    update: XOR<AnswersUpdateWithoutQuestionInput, AnswersUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswersCreateWithoutQuestionInput, AnswersUncheckedCreateWithoutQuestionInput>
  }

  export type AnswersUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswersWhereUniqueInput
    data: XOR<AnswersUpdateWithoutQuestionInput, AnswersUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswersUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswersScalarWhereInput
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AnswersScalarWhereInput = {
    AND?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    OR?: AnswersScalarWhereInput[]
    NOT?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    id?: IntFilter<"Answers"> | number
    questionid?: IntFilter<"Answers"> | number
    text?: StringFilter<"Answers"> | string
    iscorrect?: BoolNullableFilter<"Answers"> | boolean | null
  }

  export type TestTasksUpsertWithoutQuestionsInput = {
    update: XOR<TestTasksUpdateWithoutQuestionsInput, TestTasksUncheckedUpdateWithoutQuestionsInput>
    create: XOR<TestTasksCreateWithoutQuestionsInput, TestTasksUncheckedCreateWithoutQuestionsInput>
    where?: TestTasksWhereInput
  }

  export type TestTasksUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: TestTasksWhereInput
    data: XOR<TestTasksUpdateWithoutQuestionsInput, TestTasksUncheckedUpdateWithoutQuestionsInput>
  }

  export type TestTasksUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    groups?: GroupsUpdateOneRequiredWithoutTestTasksNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutTestTasksNestedInput
  }

  export type TestTasksUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    groupid?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacherid?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionsCreateWithoutAnswersInput = {
    description: string
    img?: string | null
    testtasks: TestTasksCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutAnswersInput = {
    id?: number
    description: string
    img?: string | null
    testtaskid: number
  }

  export type QuestionsCreateOrConnectWithoutAnswersInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionsUpsertWithoutAnswersInput = {
    update: XOR<QuestionsUpdateWithoutAnswersInput, QuestionsUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionsCreateWithoutAnswersInput, QuestionsUncheckedCreateWithoutAnswersInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutAnswersInput, QuestionsUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionsUpdateWithoutAnswersInput = {
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    testtasks?: TestTasksUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    testtaskid?: IntFieldUpdateOperationsInput | number
  }

  export type StudentsCreateWithoutGradesInput = {
    name: string
    lastname: string
    patronymic: string
    users: UserCreateNestedOneWithoutStudentsInput
    group: GroupsCreateNestedOneWithoutStudentsInput
  }

  export type StudentsUncheckedCreateWithoutGradesInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userId: number
    groupId: number
  }

  export type StudentsCreateOrConnectWithoutGradesInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutGradesInput, StudentsUncheckedCreateWithoutGradesInput>
  }

  export type StudentsUpsertWithoutGradesInput = {
    update: XOR<StudentsUpdateWithoutGradesInput, StudentsUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentsCreateWithoutGradesInput, StudentsUncheckedCreateWithoutGradesInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutGradesInput, StudentsUncheckedUpdateWithoutGradesInput>
  }

  export type StudentsUpdateWithoutGradesInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutStudentsNestedInput
    group?: GroupsUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateWithoutGradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyRoleInput = {
    id?: number
    passwordhash: string
    login: string
    date?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherUpdateOneWithoutUsersNestedInput
    students?: StudentsUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherUncheckedUpdateOneWithoutUsersNestedInput
    students?: StudentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    passwordhash?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentsCreateManyUsersInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    groupId: number
  }

  export type StudentsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    group?: GroupsUpdateOneRequiredWithoutStudentsNestedInput
    grades?: GradesUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
    grades?: GradesUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsCreateManyTeacherInput = {
    id?: number
    groupId: number
  }

  export type TestTasksCreateManyTeacherInput = {
    id?: number
    title: string
    groupid: number
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
  }

  export type TeacherGroupsUpdateWithoutTeacherInput = {
    group?: GroupsUpdateOneRequiredWithoutTeacherGroupsNestedInput
  }

  export type TeacherGroupsUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTasksUpdateWithoutTeacherInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    groups?: GroupsUpdateOneRequiredWithoutTestTasksNestedInput
    questions?: QuestionsUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    groupid?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    questions?: QuestionsUncheckedUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    groupid?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
  }

  export type StudentsCreateManyGroupInput = {
    id?: number
    name: string
    lastname: string
    patronymic: string
    userId: number
  }

  export type TeacherGroupsCreateManyGroupInput = {
    id?: number
    teacherId: number
  }

  export type TestTasksCreateManyGroupsInput = {
    id?: number
    title: string
    description: string
    img?: string | null
    beginningdate: Date | string
    enddatetime: Date | string
    time: number
    teacherid: number
  }

  export type StudentsUpdateWithoutGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutStudentsNestedInput
    grades?: GradesUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    grades?: GradesUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    patronymic?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsUpdateWithoutGroupInput = {
    teacher?: TeacherUpdateOneRequiredWithoutTeacherGroupsNestedInput
  }

  export type TeacherGroupsUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherGroupsUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
  }

  export type TestTasksUpdateWithoutGroupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacher?: TeacherUpdateOneRequiredWithoutTestTasksNestedInput
    questions?: QuestionsUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacherid?: IntFieldUpdateOperationsInput | number
    questions?: QuestionsUncheckedUpdateManyWithoutTesttasksNestedInput
  }

  export type TestTasksUncheckedUpdateManyWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    beginningdate?: DateTimeFieldUpdateOperationsInput | Date | string
    enddatetime?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: IntFieldUpdateOperationsInput | number
    teacherid?: IntFieldUpdateOperationsInput | number
  }

  export type GradesCreateManyStudentsInput = {
    id?: number
    grade: number
    date: Date | string
  }

  export type GradesUpdateWithoutStudentsInput = {
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradesUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradesUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionsCreateManyTesttasksInput = {
    id?: number
    description: string
    img?: string | null
  }

  export type QuestionsUpdateWithoutTesttasksInput = {
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswersUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutTesttasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: AnswersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionsUncheckedUpdateManyWithoutTesttasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswersCreateManyQuestionInput = {
    id?: number
    text: string
    iscorrect?: boolean | null
  }

  export type AnswersUpdateWithoutQuestionInput = {
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnswersUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnswersUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    iscorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}